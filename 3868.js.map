{"version":3,"file":"3868.js","mappings":"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","sources":["webpack://aisa/./src/SkyBox.ts","webpack://aisa/./src/blender/BlenderJsonParser.ts","webpack://aisa/./src/animation/CameraKeyFrame.ts","webpack://aisa/./src/camera/CameraPath.ts","webpack://aisa/./src/camera/CameraFrame.ts","webpack://aisa/./src/camera/CameraLoader.ts","webpack://aisa/./src/blender/mesh.ts","webpack://aisa/./src/blender/vector.ts","webpack://aisa/./src/blender/tex-coord.ts","webpack://aisa/./src/blender/face.ts","webpack://aisa/./src/blender/parseUtils.ts","webpack://aisa/./src/model/wavefront-obj/WavefrontLoader.ts","webpack://aisa/./src/camera/EulerAngleCamera.ts","webpack://aisa/./src/animation/BlenderCameraAnimator.ts","webpack://aisa/./src/examples/blender-camera-animation/BlenderCameraScene.ts","webpack://aisa/./src/examples/demo/parts/Scene9.ts","webpack://aisa/./src/math/Geometry.ts","webpack://aisa/./src/math/Sphere.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { Framebuffer } from './Framebuffer';\nimport { Matrix4f, Vector4f } from './math';\nimport { Texture, TextureUtils } from './texture';\nimport { TextureCoordinate } from './TextureCoordinate';\nimport { TexturingRenderingPipeline } from './rendering-pipelines/TexturingRenderingPipeline';\nimport { TexturedMesh } from './rendering-pipelines/TexturedMesh';\n\nexport class SkyBox {\n\n    private back: Texture;\n    private down: Texture;\n    private front: Texture;\n    private left: Texture;\n    private right: Texture;\n    private up: Texture;\n\n    private texturedRenderingPipeline: TexturingRenderingPipeline = new TexturingRenderingPipeline(null);\n    public init(): Promise<any> {\n\n        return Promise.all([\n            TextureUtils.load(require('@assets/skybox/skybox_back.png'), false).then(\n                (texture: Texture) => this.back = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_down.png'), false).then(\n                (texture: Texture) => this.down = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_front.png'), false).then(\n                (texture: Texture) => this.front = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_left.png'), false).then(\n                (texture: Texture) => this.left = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_right.png'), false).then(\n                (texture: Texture) => this.right = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_up.png'), false).then(\n                (texture: Texture) => this.up = texture\n            )]).then(() => {\n                this.back.setClamp(true);\n                this.down.setClamp(true);\n                this.front.setClamp(true);\n                this.left.setClamp(true);\n                this.right.setClamp(true);\n                this.up.setClamp(true);\n            });\n    }\n\n    // move code from framebuffer into draw method!\n    public draw(framebuffer: Framebuffer, mv: Matrix4f): void {\n    \n        this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n        this.drawSkyBox(framebuffer, mv.getRotation());\n    }\n\n    public drawSkyBox(framebuffer: Framebuffer, rotation: Matrix4f): void {\n        const sclae = 20;\n        const textures = [\n            this.back,\n            this.left,\n            this.front,\n            this.right\n        ];\n\n        let camera: Matrix4f;\n        let mv: Matrix4f;\n        let skyBoxSideModel: TexturedMesh;\n\n        const skyPoints = [\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, -1, -1, 1)\n        ];\n\n        for (let i = 0; i < 4; i++) {\n            camera =\n                rotation.multiplyMatrix(\n                    Matrix4f.constructXRotationMatrix(Math.PI).multiplyMatrix(\n                        Matrix4f.constructYRotationMatrix(+ Math.PI * 2 / 4 * i)));\n\n\n            mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n\n            // skybox: starz\n            skyBoxSideModel = {\n                points: skyPoints,\n                points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n                uv: [\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 0),\n                ],\n                faces: [\n                    {\n                        vertices: [0, 1, 2],\n                        uv: [0, 1, 2]\n                    },\n                    {\n                        vertices: [3, 4, 5],\n                        uv: [3, 4, 5]\n                    }\n                ]\n            };\n\n            framebuffer.setTexture(textures[i]);\n            this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n            this.texturedRenderingPipeline.setModelViewMatrix(mv);\n            this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n        }\n\n        camera = rotation.multiplyMatrix(\n            Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                Matrix4f.constructYRotationMatrix(0)\n                    .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 4 * 1).multiplyMatrix(Matrix4f.constructXRotationMatrix(-Math.PI * 2 / 4)))\n            );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.up);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n\n        camera =\n            rotation.multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(0)\n                        .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 2).multiplyMatrix(Matrix4f.constructXRotationMatrix(Math.PI * 2 / 4)))\n\n                );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.down);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n    }\n\n}\n","import { FlatShadedFace } from '../geometrical-objects/FlatShadedFace';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { BlenderScene } from './BlenderScene';\nimport { Face } from './face';\nimport { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexturedMesh } from '../rendering-pipelines/TexturedMesh';\nimport { TextureCoordinate } from '../TextureCoordinate';\nimport { ComputationalGeometryUtils } from '../math/Geometry';\nimport { TexCoord } from './tex-coord';\n\nexport class BlenderJsonParser {\n\n    public static parse(blenderScene: BlenderScene, invert: boolean = false): Array<FlatshadedMesh> {\n        const scene: Array<FlatshadedMesh> = [];\n\n        blenderScene.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n\n            object.vertices.forEach((v: Vector) => {\n                points.push(new Vector4f(v.x, v.y, v.z).mul(1));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(\n                    invert ? new Vector4f(v.x, v.y, v.z).normalize().mul(-1) : new Vector4f(v.x, v.y, v.z).normalize()\n                );\n            });\n\n            const faces: Array<FlatShadedFace> = [];\n            object.faces.forEach((f: Face) => {\n                faces.push({\n                    n1: f.normals[0],\n                    n2: f.normals[1],\n                    n3: f.normals[2],\n                    v1: f.vertices[0],\n                    v2: f.vertices[1],\n                    v3: f.vertices[2],\n                });\n            });\n\n            const obj: FlatshadedMesh = {\n                faces,\n                normals,\n                points,\n                transformedNormals: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                transformedPoints: points.map(() => new Vector4f(0, 0, 0, 0)),\n            };\n\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n    public static getBlenderScene(\n        file: BlenderScene, disp: boolean = true): Array<TexturedMesh> {\n        const scene: Array<TexturedMesh> = [];\n\n        file.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n            let coords: Array<TextureCoordinate>;\n\n            if (object.uv) {\n                coords = [];\n                object.uv.forEach((v: TexCoord) => {\n                    const uv: TextureCoordinate = new TextureCoordinate();\n                    uv.u = v.u;\n                    uv.v = 1.0 - v.v;\n                    coords.push(uv);\n                });\n            }\n\n            object.vertices.forEach((v: Vector) => {\n                // some transformation in order for the vertices to be in worldspace\n                if (disp)\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2).add(new Vector4f(0, -2.7, 0, 0)));\n                else\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(new Vector4f(v.x, v.y, v.z));\n            });\n\n            const sphere = new ComputationalGeometryUtils().computeBoundingSphere(points);\n            sphere.getCenter().w = 1;\n\n            // Create class for objects\n            const obj = {\n                points,\n                normals,\n                uv: coords,           // NO!!!\n                faces: object.faces, // NOO!!!\n                points2: points.map(() => new Vector4f(0, 0, 0, 0)),\n                normals2: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                boundingSphere: sphere, // NO!!!\n                name: object.name /// NO!\n            };\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n}\n","import { Vector3f } from '../math';\n\nexport class CameraKeyFrame {\n\n    public position: Vector3f;\n    public rotation: Vector3f;\n\n    constructor(position: Vector3f, rotation: Vector3f) {\n        this.position = position;\n        this.rotation = rotation;\n    }\n\n}","import { CameraFrame } from './CameraFrame';\n\nexport class CameraPath {\n    public frames: Array<CameraFrame>;\n    constructor() {\n        this.frames = new Array<CameraFrame>();\n    }\n}\n\n","import { Vector3f } from '../math';\n\nexport class CameraFrame {\n    public frame: number;\n    public position: Vector3f;\n    public rotation: Vector3f;\n\n    constructor(frame: number, position: Vector3f, rotation: Vector3f) {\n        this.frame = frame;\n        this.position = position;\n        this.rotation = rotation;\n    }\n}\n","import { CameraKeyFrame } from '../animation/CameraKeyFrame';\nimport { Vector3f } from '../math';\nimport { CameraPath } from './CameraPath';\nimport { CameraFrame } from './CameraFrame';\n\nexport class CameraLoader {\n\n    public static load(filename: string): Promise<Array<CameraKeyFrame>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<CameraKeyFrame> => {\n\n            const json: any = JSON.parse(text);\n            const cameraPath: CameraPath = new CameraPath();\n            const keys = new Array<CameraKeyFrame>();\n\n            for (let i = 0; i < json.length; i++) {\n                const frame = json[i];\n\n                const myFrame = new CameraFrame(\n                    frame.frame,\n                    new Vector3f(\n                        frame.location[0],\n                        frame.location[1],\n                        frame.location[2]\n                    ),\n                    new Vector3f(\n                        frame.rotation[0],\n                        frame.rotation[1],\n                        frame.rotation[2]\n                    ));\n\n                cameraPath.frames.push(myFrame);\n                keys.push(new CameraKeyFrame(new Vector3f(\n                    frame.location[0],\n                    frame.location[2],\n                    -frame.location[1]\n                ),\n                    new Vector3f(\n                        frame.rotation[0] - 90 * 0.0174533,\n                        frame.rotation[2],\n                        frame.rotation[1]\n                    )));\n\n            }\n\n            return keys;\n        });\n    }\n\n}\n","import { Face } from './face';\nimport { TexCoord } from './tex-coord';\nimport { Vector } from './vector';\n\nexport class Mesh {\n\n    public name: string;\n    public vertices: Array<Vector>;\n    public normals: Array<Vector>;\n    public uv: Array<TexCoord>;\n    public faces: Array<Face>;\n\n}\n","export class Vector {\n\n    public x: number;\n    public y: number;\n    public z: number;\n\n    public constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n}\n","\nexport class TexCoord {\n\n    public u: number;\n    public v: number;\n\n    public constructor(u: number, v: number) {\n        this.u = u;\n        this.v = v;\n    }\n\n}\n","export class Face {\n    public vertices: Array<number>;\n    public normals: Array<number>;\n    public uv: Array<number>;\n}\n","import { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexCoord } from './tex-coord';\nimport { Face } from './face';\n\nexport function convertToMeshArray(data: string): Array<Mesh> {\n    const json: Array<Mesh> = new Array<Mesh>();\n\n    let currentObject: Mesh = null;\n\n    let normalCount: number = 0;\n    let vertexCount: number = 0;\n    let uvCount: number = 0;\n    let normalOffset: number = 0;\n    let vertexOffset: number = 0;\n    let uvOffset: number = 0;\n\n    data.toString().split('\\n').forEach((line: string) => {\n\n        if (line.startsWith('o ')) {\n            const coords: Array<string> = line.split(' ');\n\n            currentObject = new Mesh();\n            currentObject.name = coords[1];\n            currentObject.normals = [];\n            currentObject.vertices = [];\n            currentObject.faces = [];\n            currentObject.uv = []; // OPTIONAL\n\n            json.push(currentObject);\n            normalOffset = normalCount;\n            vertexOffset = vertexCount;\n            uvOffset = uvCount;\n        }\n\n        if (currentObject === null &&\n            (line.startsWith('v ') ||\n                line.startsWith('vn ') ||\n                line.startsWith('vt '))) {\n            console.error('Error: OBJ file does not contain Objects.');\n            throw Error();\n        }\n\n        if (line.startsWith('v ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const vertex: Vector = new Vector(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2]),\n                Number.parseFloat(coords[3])\n            );\n\n            currentObject.vertices.push(vertex);\n            vertexCount++;\n        }\n\n        if (line.startsWith('vn ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const normal: Vector = new Vector(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2]),\n                Number.parseFloat(coords[3])\n            );\n\n            currentObject.normals.push(normal);\n            normalCount++;\n        }\n\n        if (line.startsWith('vt ')) { // OPTIONAL\n            const coords: Array<string> = line.split(' ');\n\n            const uv: TexCoord = new TexCoord(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2])\n            );\n\n            currentObject.uv.push(uv);\n            uvCount++;\n        }\n\n        if (line.startsWith('f ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const face: Face = new Face();\n            face.vertices = [];\n            face.normals = [];\n            face.uv = [];\n\n            // vertex indices\n            face.vertices.push(Number(coords[1].split('/')[0]) - 1 - vertexOffset);\n            face.vertices.push(Number(coords[2].split('/')[0]) - 1 - vertexOffset);\n            face.vertices.push(Number(coords[3].split('/')[0]) - 1 - vertexOffset);\n\n            // uv indices OPTIONAL!\n            face.uv.push(Number(coords[1].split('/')[1]) - 1 - uvOffset);\n            face.uv.push(Number(coords[2].split('/')[1]) - 1 - uvOffset);\n            face.uv.push(Number(coords[3].split('/')[1]) - 1 - uvOffset);\n\n            // normal indices\n            face.normals.push(Number(coords[1].split('/')[2]) - 1 - normalOffset);\n            face.normals.push(Number(coords[2].split('/')[2]) - 1 - normalOffset);\n            face.normals.push(Number(coords[3].split('/')[2]) - 1 - normalOffset);\n\n            currentObject.faces.push(face);\n        }\n    });\n\n    return json;\n}\n","import { BlenderJsonParser } from '../../blender/BlenderJsonParser';\nimport { Mesh } from '../../blender/mesh';\nimport { convertToMeshArray } from '../../blender/parseUtils';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\n\nexport class WavefrontLoader {\n\n    private flatMeshes: Array<FlatshadedMesh>;\n    private texMeshes: Array<TexturedMesh>;\n\n    private constructor(flatMeshes: Array<FlatshadedMesh> = [], texMeshes: Array<TexturedMesh> = []) {\n        this.flatMeshes = flatMeshes;\n        this.texMeshes = texMeshes;\n    }\n\n    /**\n     * Returns the loaded flat-shaded meshes.\n     * Use {@link WavefrontLoader.loadModel} to obtain an instance.\n     */\n    public getMesh(): Array<FlatshadedMesh> {\n        return this.flatMeshes;\n    }\n\n    /**\n     * Returns the loaded textured meshes.\n     * Use {@link WavefrontLoader.loadTexturedModel} to obtain an instance.\n     */\n    public getTexturedMesh(): Array<TexturedMesh> {\n        return this.texMeshes;\n    }\n\n    /**\n     * Creates a WavefrontLoader instance with the flat-shaded meshes loaded\n     * from the given OBJ file, so that {@link getMesh} can be called on it.\n     */\n    public static loadModel(filename: any): Promise<WavefrontLoader> {\n        return WavefrontLoader.load(filename).then(\n            (meshes: Array<FlatshadedMesh>) => new WavefrontLoader(meshes, [])\n        );\n    }\n\n    /**\n     * Creates a WavefrontLoader instance with the textured meshes loaded\n     * from the given OBJ file, so that {@link getTexturedMesh} can be called on it.\n     */\n    public static loadTexturedModel(filename: any): Promise<WavefrontLoader> {\n        return WavefrontLoader.loadWithTexture(filename).then(\n            (meshes: Array<TexturedMesh>) => new WavefrontLoader([], meshes)\n        );\n    }\n\n    /** @deprecated Use {@link loadModel} for an instance-based API. */\n    public static load(filename: any): Promise<Array<FlatshadedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<Mesh> => {\n            return convertToMeshArray(text);\n        }).then((meshes: Array<Mesh>) => {\n            return BlenderJsonParser.parse(meshes);\n        });\n    }\n\n    /** @deprecated Use {@link loadTexturedModel} for an instance-based API. */\n    public static loadWithTexture(filename: any): Promise<Array<TexturedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<Mesh> => {\n            return convertToMeshArray(text);\n        }).then((meshes: Array<Mesh>) => {\n            return BlenderJsonParser.getBlenderScene(meshes);\n        });\n    }\n\n}\n","import { Matrix4f, Vector3f } from '../math';\n\nexport class EulerAngleCamera {\n\n    protected position: Vector3f;\n    protected rx: number;\n    protected ry: number;\n    protected rz: number;\n\n    constructor(position: Vector3f, rx: number, ry: number, rz: number) {\n        this.position = position;\n        this.rx = rx;\n        this.ry = ry;\n        this.rz = rz;\n    }\n\n    public getViewMatrix(): Matrix4f {\n        const rz = Matrix4f.constructZRotationMatrix(-this.rz);\n        const rx = Matrix4f.constructXRotationMatrix(-this.rx);\n        const ry = Matrix4f.constructYRotationMatrix(-this.ry);\n\n        const translation = Matrix4f.constructTranslationMatrix(-this.position.x, -this.position.y, -this.position.z);\n\n        return rx.multiplyMatrix(ry).multiplyMatrix(rz).multiplyMatrix(translation);\n    }\n\n    public getPosition(): Vector3f {\n        return this.position;\n    }\n\n}\n","import { EulerAngleCamera } from '../camera/EulerAngleCamera';\nimport { Utils } from '../core/Utils';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { Vector3f } from '../math/Vector3f';\nimport { CameraKeyFrame } from './CameraKeyFrame';\n\nexport class BlenderCameraAnimator {\n\n    public pos: Vector3f;\n    private keyFrames: Array<CameraKeyFrame>;\n\n    // TODO:\n    // - should we really loop or better restart??\n    // - dont use linear interpolation see bourke\n    // - maybe quaternions and slerp for rotation\n    // temp solution: no linear for\n\n    public setKeyFrames(keyFrames: Array<CameraKeyFrame>): void {\n        this.keyFrames = keyFrames;\n    }\n\n    public getViewMatrix(elapsedTime: number): Matrix4f {\n        const keyFrameDuration = 2600;\n\n        elapsedTime *= 1.0;\n\n        const first = ((elapsedTime / keyFrameDuration) | 0) % this.keyFrames.length;\n        const zero = ((first - 1) + this.keyFrames.length) % this.keyFrames.length;\n        const second = (first + 1) % this.keyFrames.length;\n        const third = (first + 2) % this.keyFrames.length;\n        const fraction = ((elapsedTime / keyFrameDuration) % this.keyFrames.length) - first;\n\n        const position = new Vector3f(\n            Utils.CubicInterpolate(this.keyFrames[zero].position.x, this.keyFrames[first].position.x, this.keyFrames[second].position.x, this.keyFrames[third].position.x, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].position.y, this.keyFrames[first].position.y, this.keyFrames[second].position.y, this.keyFrames[third].position.y, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].position.z, this.keyFrames[first].position.z, this.keyFrames[second].position.z, this.keyFrames[third].position.z, fraction)\n        );\n        //let look = this.keyFrames[first].rotation.mul(1 - mu2).add(this.keyFrames[second].rotation.mul(mu2));\n\n        const look = new Vector3f(\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.x, this.keyFrames[first].rotation.x, this.keyFrames[second].rotation.x, this.keyFrames[third].rotation.x, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.y, this.keyFrames[first].rotation.y, this.keyFrames[second].rotation.y, this.keyFrames[third].rotation.y, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.z, this.keyFrames[first].rotation.z, this.keyFrames[second].rotation.z, this.keyFrames[third].rotation.z, fraction)\n        );\n        this.pos = position;\n\n        return new EulerAngleCamera(position, look.x, look.y, look.z).getViewMatrix();\n    }\n\n}\n\n","import { CameraKeyFrame } from '../../animation/CameraKeyFrame';\nimport { CameraLoader } from '../../camera/CameraLoader';\nimport { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { Matrix4f, Vector4f } from '../../math';\nimport { WavefrontLoader } from '../../model/wavefront-obj/WavefrontLoader';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { PointLight } from '../../shading/light/PointLight';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\n\nimport { BlenderCameraAnimator } from '../../animation/BlenderCameraAnimator';\nimport { SkyBox } from '../../SkyBox';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\n\nexport class BlenderCameraScene extends AbstractScene {\n\n    private texture4: Texture;\n    private fpsStartTime: number = Date.now();\n    private fpsCount: number = 0;\n    private fps: number = 0;\n\n    private meshes: Array<FlatshadedMesh>;\n    private path: Array<CameraKeyFrame>;\n    private skyBox: SkyBox;\n\n    private light1: PointLight;\n    private light2: PointLight;\n\n    private cameraAnimator: BlenderCameraAnimator;\n\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.renderingPipeline.setCullFace(CullFace.BACK);\n\n        this.light1 = new PointLight();\n        this.light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        this.light1.diffuseIntensity = new Vector4f(1, 0.0, 1, 1);\n        this.light1.specularIntensity = new Vector4f(0.5, 0.5, 0.7, 1);\n        this.light1.position = new Vector4f(0, -10, -1, 1);\n\n        this.light2 = new PointLight();\n        this.light2.ambientIntensity = new Vector4f(0.5, 0.5, 1, 1);\n        this.light2.diffuseIntensity = new Vector4f(0.3, 0.3, 1, 1);\n        this.light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        this.light2.position = new Vector4f(3, 0, -2, 1);\n\n        this.renderingPipeline.setLights([this.light1, this.light2]);\n\n        this.skyBox = new SkyBox();\n        return Promise.all([\n            this.skyBox.init(),\n            WavefrontLoader.load(require('@assets/wavefront/monkey.obj')).then(\n                (value: Array<FlatshadedMesh>) => this.meshes = value\n            ),\n            CameraLoader.load(require('@assets/camera-path.jsx')).then(\n                (value: Array<CameraKeyFrame>) => this.path = value\n            ),\n            TextureUtils.load(require('@assets/fonts/font.png'), true).then(\n                (texture: Texture) => this.texture4 = texture),\n        ]).then(() => {\n            this.cameraAnimator = new BlenderCameraAnimator();\n            this.cameraAnimator.setKeyFrames(this.path);\n        });\n    }\n\n    private computeFps(currentTime: number): void {\n        if (currentTime > this.fpsStartTime + 1000) {\n            this.fpsStartTime = currentTime;\n            this.fps = this.fpsCount;\n            this.fpsCount = 0;\n        }\n        this.fpsCount++;\n    }\n\n    public render(framebuffer: Framebuffer, timeInput: number): void {\n        const currentTime: number = Date.now();\n        this.computeFps(currentTime);\n\n        const modelViewMartrix: Matrix4f = this.cameraAnimator.getViewMatrix(timeInput);\n\n        this.skyBox.draw(framebuffer, modelViewMartrix);\n\n        framebuffer.clearDepthBuffer();\n        this.renderingPipeline.drawMeshArray(framebuffer, this.meshes, modelViewMartrix);\n\n        framebuffer.drawText(8, 8, 'FPS: ' + this.fps.toString(), this.texture4);\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { BlenderCameraScene } from '../../blender-camera-animation/BlenderCameraScene';\nexport class Scene9 {\n    private BlenderCameraScene: BlenderCameraScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.BlenderCameraScene = new BlenderCameraScene();\n\n        return Promise.all([\n            this.BlenderCameraScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        framebuffer.clearColorBuffer(0);\n        framebuffer.clearDepthBuffer();\n        this.BlenderCameraScene.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from './index';\nimport { Sphere } from './Sphere';\n\nexport class ComputationalGeometryUtils {\n\n    public computeBoundingSphere(vertices: Array<Vector4f>): Sphere {\n\n        if (vertices.length === 0) {\n            throw new Error('More than one vertex required.');\n        }\n\n        if (vertices.length === 1) {\n            return new Sphere(vertices[0], 0);\n        }\n\n        let center = new Vector4f(0, 0, 0, 0);\n        let radius = 0;\n\n        vertices.forEach(point => {\n            center = center.add(new Vector4f(point.x, point.y, point.z, 0.0));\n        });\n\n        center = center.mul(1.0 / vertices.length);\n\n        vertices.forEach(point => {\n            radius = Math.max(radius, center.sub(point).length());\n        });\n\n        return new Sphere(center, radius);\n    }\n\n}\n","import { BoundingVolume } from './BoundingVolume';\nimport { Vector4f } from './index';\nimport { Matrix4f } from './Matrix4f';\nimport { Plane } from './Plane';\n\nexport class Sphere implements BoundingVolume {\n\n    private center: Vector4f;\n    private radius: number;\n\n    public constructor(position: Vector4f, radius: number) {\n        this.center = position;\n        this.radius = radius;\n    }\n\n    /**\n     *\n     * @param {Plane} plane\n     * @returns {boolean}\n     * @memberof Sphere\n     */\n    public isInsidePositiveHalfSpace(plane: Plane): boolean {\n        return plane.getNormal().dot(this.center) - plane.getDistance() > - this.radius;\n    }\n\n    public getTran(mat: Matrix4f): Vector4f {\n        return mat.multiplyHom(this.center);\n    }\n\n    public getRadius(): number {\n        return this.radius;\n    }\n\n    public getCenter(): Vector4f {\n        return this.center;\n    }\n\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["SkyBox","back","down","front","left","right","up","texturedRenderingPipeline","init","Promise","all","load","then","texture","this","setClamp","draw","framebuffer","mv","setFramebuffer","drawSkyBox","getRotation","rotation","sclae","textures","camera","skyBoxSideModel","skyPoints","i","multiplyMatrix","constructXRotationMatrix","Math","PI","constructYRotationMatrix","constructScaleMatrix","points","points2","map","uv","faces","vertices","setTexture","setModelViewMatrix","BlenderJsonParser","parse","blenderScene","invert","scene","forEach","object","Array","normals","v","push","x","y","z","mul","normalize","f","n1","n2","n3","v1","v2","v3","obj","transformedNormals","transformedPoints","getBlenderScene","file","disp","coords","u","add","sphere","computeBoundingSphere","getCenter","w","normals2","boundingSphere","name","CameraKeyFrame","position","constructor","CameraPath","frames","CameraFrame","frame","CameraLoader","filename","fetch","response","text","json","JSON","cameraPath","keys","length","myFrame","Vector3f","location","Mesh","Vector","TexCoord","Face","convertToMeshArray","data","currentObject","normalCount","vertexCount","uvCount","normalOffset","vertexOffset","uvOffset","toString","split","line","startsWith","console","error","Error","vertex","Number","parseFloat","normal","face","WavefrontLoader","flatMeshes","texMeshes","getMesh","getTexturedMesh","loadModel","meshes","loadTexturedModel","loadWithTexture","EulerAngleCamera","rx","ry","rz","getViewMatrix","Matrix4f","constructZRotationMatrix","translation","constructTranslationMatrix","getPosition","BlenderCameraAnimator","pos","keyFrames","setKeyFrames","elapsedTime","first","zero","second","third","fraction","Utils","CubicInterpolate","look","BlenderCameraScene","AbstractScene","texture4","fpsStartTime","Date","now","fpsCount","fps","path","skyBox","light1","light2","cameraAnimator","renderingPipeline","GouraudShadingRenderingPipeline","setCullFace","CullFace","BACK","PointLight","ambientIntensity","Vector4f","diffuseIntensity","specularIntensity","setLights","value","TextureUtils","computeFps","currentTime","render","timeInput","modelViewMartrix","clearDepthBuffer","drawMeshArray","drawText","Scene9","time","clearColorBuffer","ComputationalGeometryUtils","center","radius","point","max","sub","Sphere","isInsidePositiveHalfSpace","plane","getNormal","dot","getDistance","getTran","mat","multiplyHom","getRadius","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","r","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","super","fillLongRightTriangle","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","round","currentX","framebufferIndex","width","spanzStep","currentZ","wStart","j","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","vertexArray","ambientColor","diffuseColor","specularColor","shininess","setFog","enableLighting","enable","setMaterial","setColor","model","mesh","normalMatrix","computeNormalMatrix","multiplyHomArr","normal1","normal2","normal3","isInFrontOfNearPlane","project2","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","height","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","subject","input","S","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","scale","pow","Light","Material","emissiveColor"],"sourceRoot":""}