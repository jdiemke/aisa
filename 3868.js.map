{"version":3,"file":"3868.js","mappings":"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","sources":["webpack://aisa/./src/SkyBox.ts","webpack://aisa/./src/blender/BlenderJsonParser.ts","webpack://aisa/./src/animation/CameraKeyFrame.ts","webpack://aisa/./src/camera/CameraPath.ts","webpack://aisa/./src/camera/CameraFrame.ts","webpack://aisa/./src/camera/CameraLoader.ts","webpack://aisa/./src/blender/mesh.ts","webpack://aisa/./src/blender/vector.ts","webpack://aisa/./src/blender/tex-coord.ts","webpack://aisa/./src/blender/face.ts","webpack://aisa/./src/blender/parseUtils.ts","webpack://aisa/./src/model/wavefront-obj/WavefrontLoader.ts","webpack://aisa/./src/camera/EulerAngleCamera.ts","webpack://aisa/./src/animation/BlenderCameraAnimator.ts","webpack://aisa/./src/examples/blender-camera-animation/BlenderCameraScene.ts","webpack://aisa/./src/examples/demo/parts/Scene9.ts","webpack://aisa/./src/math/Geometry.ts","webpack://aisa/./src/math/Sphere.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { Framebuffer } from './Framebuffer';\nimport { Matrix4f, Vector4f } from './math';\nimport { Texture, TextureUtils } from './texture';\nimport { TextureCoordinate } from './TextureCoordinate';\nimport { TexturingRenderingPipeline } from './rendering-pipelines/TexturingRenderingPipeline';\nimport { TexturedMesh } from './rendering-pipelines/TexturedMesh';\n\nexport class SkyBox {\n\n    private back: Texture;\n    private down: Texture;\n    private front: Texture;\n    private left: Texture;\n    private right: Texture;\n    private up: Texture;\n\n    private texturedRenderingPipeline: TexturingRenderingPipeline = new TexturingRenderingPipeline(null);\n    public init(): Promise<any> {\n\n        return Promise.all([\n            TextureUtils.load(require('./assets/skybox/skybox_back.png'), false).then(\n                (texture: Texture) => this.back = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_down.png'), false).then(\n                (texture: Texture) => this.down = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_front.png'), false).then(\n                (texture: Texture) => this.front = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_left.png'), false).then(\n                (texture: Texture) => this.left = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_right.png'), false).then(\n                (texture: Texture) => this.right = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_up.png'), false).then(\n                (texture: Texture) => this.up = texture\n            )]).then(() => {\n                this.back.setClamp(true);\n                this.down.setClamp(true);\n                this.front.setClamp(true);\n                this.left.setClamp(true);\n                this.right.setClamp(true);\n                this.up.setClamp(true);\n            });\n    }\n\n    // move code from framebuffer into draw method!\n    public draw(framebuffer: Framebuffer, mv: Matrix4f): void {\n    \n        this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n        this.drawSkyBox(framebuffer, mv.getRotation());\n    }\n\n    public drawSkyBox(framebuffer: Framebuffer, rotation: Matrix4f): void {\n        const sclae = 20;\n        const textures = [\n            this.back,\n            this.left,\n            this.front,\n            this.right\n        ];\n\n        let camera: Matrix4f;\n        let mv: Matrix4f;\n        let skyBoxSideModel: TexturedMesh;\n\n        const skyPoints = [\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, -1, -1, 1)\n        ];\n\n        for (let i = 0; i < 4; i++) {\n            camera =\n                rotation.multiplyMatrix(\n                    Matrix4f.constructXRotationMatrix(Math.PI).multiplyMatrix(\n                        Matrix4f.constructYRotationMatrix(+ Math.PI * 2 / 4 * i)));\n\n\n            mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n\n            // skybox: starz\n            skyBoxSideModel = {\n                points: skyPoints,\n                points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n                uv: [\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 0),\n                ],\n                faces: [\n                    {\n                        vertices: [0, 1, 2],\n                        uv: [0, 1, 2]\n                    },\n                    {\n                        vertices: [3, 4, 5],\n                        uv: [3, 4, 5]\n                    }\n                ]\n            };\n\n            framebuffer.setTexture(textures[i]);\n            this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n            this.texturedRenderingPipeline.setModelViewMatrix(mv);\n            this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n        }\n\n        camera = rotation.multiplyMatrix(\n            Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                Matrix4f.constructYRotationMatrix(0)\n                    .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 4 * 1).multiplyMatrix(Matrix4f.constructXRotationMatrix(-Math.PI * 2 / 4)))\n            );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.up);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n\n        camera =\n            rotation.multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(0)\n                        .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 2).multiplyMatrix(Matrix4f.constructXRotationMatrix(Math.PI * 2 / 4)))\n\n                );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.down);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n    }\n\n}\n","import { FlatShadedFace } from '../geometrical-objects/FlatShadedFace';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { BlenderScene } from './BlenderScene';\nimport { Face } from './face';\nimport { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexturedMesh } from '../rendering-pipelines/TexturedMesh';\nimport { TextureCoordinate } from '../TextureCoordinate';\nimport { ComputationalGeometryUtils } from '../math/Geometry';\nimport { TexCoord } from './tex-coord';\n\nexport class BlenderJsonParser {\n\n    public static parse(blenderScene: BlenderScene, invert: boolean = false): Array<FlatshadedMesh> {\n        const scene: Array<FlatshadedMesh> = [];\n\n        blenderScene.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n\n            object.vertices.forEach((v: Vector) => {\n                points.push(new Vector4f(v.x, v.y, v.z).mul(1));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(\n                    invert ? new Vector4f(v.x, v.y, v.z).normalize().mul(-1) : new Vector4f(v.x, v.y, v.z).normalize()\n                );\n            });\n\n            const faces: Array<FlatShadedFace> = [];\n            object.faces.forEach((f: Face) => {\n                faces.push({\n                    n1: f.normals[0],\n                    n2: f.normals[1],\n                    n3: f.normals[2],\n                    v1: f.vertices[0],\n                    v2: f.vertices[1],\n                    v3: f.vertices[2],\n                });\n            });\n\n            const obj: FlatshadedMesh = {\n                faces,\n                normals,\n                points,\n                transformedNormals: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                transformedPoints: points.map(() => new Vector4f(0, 0, 0, 0)),\n            };\n\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n    public static getBlenderScene(\n        file: BlenderScene, disp: boolean = true): Array<TexturedMesh> {\n        const scene: Array<TexturedMesh> = [];\n\n        file.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n            let coords: Array<TextureCoordinate>;\n\n            if (object.uv) {\n                coords = [];\n                object.uv.forEach((v: TexCoord) => {\n                    const uv: TextureCoordinate = new TextureCoordinate();\n                    uv.u = v.u;\n                    uv.v = 1.0 - v.v;\n                    coords.push(uv);\n                });\n            }\n\n            object.vertices.forEach((v: Vector) => {\n                // some transformation in order for the vertices to be in worldspace\n                if (disp)\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2).add(new Vector4f(0, -2.7, 0, 0)));\n                else\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(new Vector4f(v.x, v.y, v.z));\n            });\n\n            const sphere = new ComputationalGeometryUtils().computeBoundingSphere(points);\n            sphere.getCenter().w = 1;\n\n            // Create class for objects\n            const obj = {\n                points,\n                normals,\n                uv: coords,           // NO!!!\n                faces: object.faces, // NOO!!!\n                points2: points.map(() => new Vector4f(0, 0, 0, 0)),\n                normals2: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                boundingSphere: sphere, // NO!!!\n                name: object.name /// NO!\n            };\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n}\n","import { Vector3f } from '../math';\n\nexport class CameraKeyFrame {\n\n    public position: Vector3f;\n    public rotation: Vector3f;\n\n    constructor(position: Vector3f, rotation: Vector3f) {\n        this.position = position;\n        this.rotation = rotation;\n    }\n\n}","import { CameraFrame } from './CameraFrame';\n\nexport class CameraPath {\n    public frames: Array<CameraFrame>;\n    constructor() {\n        this.frames = new Array<CameraFrame>();\n    }\n}\n\n","import { Vector3f } from '../math';\n\nexport class CameraFrame {\n    public frame: number;\n    public position: Vector3f;\n    public rotation: Vector3f;\n\n    constructor(frame: number, position: Vector3f, rotation: Vector3f) {\n        this.frame = frame;\n        this.position = position;\n        this.rotation = rotation;\n    }\n}\n","import { CameraKeyFrame } from '../animation/CameraKeyFrame';\nimport { Vector3f } from '../math';\nimport { CameraPath } from './CameraPath';\nimport { CameraFrame } from './CameraFrame';\n\nexport class CameraLoader {\n\n    public static load(filename: string): Promise<Array<CameraKeyFrame>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<CameraKeyFrame> => {\n\n            const json: any = JSON.parse(text);\n            const cameraPath: CameraPath = new CameraPath();\n            const keys = new Array<CameraKeyFrame>();\n\n            for (let i = 0; i < json.length; i++) {\n                const frame = json[i];\n\n                const myFrame = new CameraFrame(\n                    frame.frame,\n                    new Vector3f(\n                        frame.location[0],\n                        frame.location[1],\n                        frame.location[2]\n                    ),\n                    new Vector3f(\n                        frame.rotation[0],\n                        frame.rotation[1],\n                        frame.rotation[2]\n                    ));\n\n                cameraPath.frames.push(myFrame);\n                keys.push(new CameraKeyFrame(new Vector3f(\n                    frame.location[0],\n                    frame.location[2],\n                    -frame.location[1]\n                ),\n                    new Vector3f(\n                        frame.rotation[0] - 90 * 0.0174533,\n                        frame.rotation[2],\n                        frame.rotation[1]\n                    )));\n\n            }\n\n            return keys;\n        });\n    }\n\n}\n","import { Face } from './face';\nimport { TexCoord } from './tex-coord';\nimport { Vector } from './vector';\n\nexport class Mesh {\n\n    public name: string;\n    public vertices: Array<Vector>;\n    public normals: Array<Vector>;\n    public uv: Array<TexCoord>;\n    public faces: Array<Face>;\n\n}\n","export class Vector {\n\n    public x: number;\n    public y: number;\n    public z: number;\n\n    public constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n}\n","\nexport class TexCoord {\n\n    public u: number;\n    public v: number;\n\n    public constructor(u: number, v: number) {\n        this.u = u;\n        this.v = v;\n    }\n\n}\n","export class Face {\n    public vertices: Array<number>;\n    public normals: Array<number>;\n    public uv: Array<number>;\n}\n","import { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexCoord } from './tex-coord';\nimport { Face } from './face';\n\nexport function convertToMeshArray(data: string): Array<Mesh> {\n    const json: Array<Mesh> = new Array<Mesh>();\n\n    let currentObject: Mesh = null;\n\n    let normalCount: number = 0;\n    let vertexCount: number = 0;\n    let uvCount: number = 0;\n    let normalOffset: number = 0;\n    let vertexOffset: number = 0;\n    let uvOffset: number = 0;\n\n    data.toString().split('\\n').forEach((line: string) => {\n\n        if (line.startsWith('o ')) {\n            const coords: Array<string> = line.split(' ');\n\n            currentObject = new Mesh();\n            currentObject.name = coords[1];\n            currentObject.normals = [];\n            currentObject.vertices = [];\n            currentObject.faces = [];\n            currentObject.uv = []; // OPTIONAL\n\n            json.push(currentObject);\n            normalOffset = normalCount;\n            vertexOffset = vertexCount;\n            uvOffset = uvCount;\n        }\n\n        if (currentObject === null &&\n            (line.startsWith('v ') ||\n                line.startsWith('vn ') ||\n                line.startsWith('vt '))) {\n            console.error('Error: OBJ file does not contain Objects.');\n            throw Error();\n        }\n\n        if (line.startsWith('v ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const vertex: Vector = new Vector(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2]),\n                Number.parseFloat(coords[3])\n            );\n\n            currentObject.vertices.push(vertex);\n            vertexCount++;\n        }\n\n        if (line.startsWith('vn ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const normal: Vector = new Vector(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2]),\n                Number.parseFloat(coords[3])\n            );\n\n            currentObject.normals.push(normal);\n            normalCount++;\n        }\n\n        if (line.startsWith('vt ')) { // OPTIONAL\n            const coords: Array<string> = line.split(' ');\n\n            const uv: TexCoord = new TexCoord(\n                Number.parseFloat(coords[1]),\n                Number.parseFloat(coords[2])\n            );\n\n            currentObject.uv.push(uv);\n            uvCount++;\n        }\n\n        if (line.startsWith('f ')) {\n            const coords: Array<string> = line.split(' ');\n\n            const face: Face = new Face();\n            face.vertices = [];\n            face.normals = [];\n            face.uv = [];\n\n            // vertex indices\n            face.vertices.push(Number(coords[1].split('/')[0]) - 1 - vertexOffset);\n            face.vertices.push(Number(coords[2].split('/')[0]) - 1 - vertexOffset);\n            face.vertices.push(Number(coords[3].split('/')[0]) - 1 - vertexOffset);\n\n            // uv indices OPTIONAL!\n            face.uv.push(Number(coords[1].split('/')[1]) - 1 - uvOffset);\n            face.uv.push(Number(coords[2].split('/')[1]) - 1 - uvOffset);\n            face.uv.push(Number(coords[3].split('/')[1]) - 1 - uvOffset);\n\n            // normal indices\n            face.normals.push(Number(coords[1].split('/')[2]) - 1 - normalOffset);\n            face.normals.push(Number(coords[2].split('/')[2]) - 1 - normalOffset);\n            face.normals.push(Number(coords[3].split('/')[2]) - 1 - normalOffset);\n\n            currentObject.faces.push(face);\n        }\n    });\n\n    return json;\n}\n","import { BlenderJsonParser } from '../../blender/BlenderJsonParser';\nimport { Mesh } from '../../blender/mesh';\nimport { convertToMeshArray } from '../../blender/parseUtils';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\n\nexport class WavefrontLoader {\n\n    public static load(filename: any): Promise<Array<FlatshadedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<Mesh> => {\n            return convertToMeshArray(text);\n        }).then((meshes: Array<Mesh>) => {\n            return BlenderJsonParser.parse(meshes);\n        });\n    }\n\n    public static loadWithTexture(filename: any): Promise<Array<TexturedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.text();\n        }).then((text: string): Array<Mesh> => {\n            return convertToMeshArray(text);\n        }).then((meshes: Array<Mesh>) => {\n            return BlenderJsonParser.getBlenderScene(meshes);\n        });\n    }\n\n    private constructor() {\n\n    }\n\n}\n","import { Matrix4f, Vector3f } from '../math';\n\nexport class EulerAngleCamera {\n\n    protected position: Vector3f;\n    protected rx: number;\n    protected ry: number;\n    protected rz: number;\n\n    constructor(position: Vector3f, rx: number, ry: number, rz: number) {\n        this.position = position;\n        this.rx = rx;\n        this.ry = ry;\n        this.rz = rz;\n    }\n\n    public getViewMatrix(): Matrix4f {\n        const rz = Matrix4f.constructZRotationMatrix(-this.rz);\n        const rx = Matrix4f.constructXRotationMatrix(-this.rx);\n        const ry = Matrix4f.constructYRotationMatrix(-this.ry);\n\n        const translation = Matrix4f.constructTranslationMatrix(-this.position.x, -this.position.y, -this.position.z);\n\n        return rx.multiplyMatrix(ry).multiplyMatrix(rz).multiplyMatrix(translation);\n    }\n\n    public getPosition(): Vector3f {\n        return this.position;\n    }\n\n}\n","import { EulerAngleCamera } from '../camera/EulerAngleCamera';\nimport { Utils } from '../core/Utils';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { Vector3f } from '../math/Vector3f';\nimport { CameraKeyFrame } from './CameraKeyFrame';\n\nexport class BlenderCameraAnimator {\n\n    public pos: Vector3f;\n    private keyFrames: Array<CameraKeyFrame>;\n\n    // TODO:\n    // - should we really loop or better restart??\n    // - dont use linear interpolation see bourke\n    // - maybe quaternions and slerp for rotation\n    // temp solution: no linear for\n\n    public setKeyFrames(keyFrames: Array<CameraKeyFrame>): void {\n        this.keyFrames = keyFrames;\n    }\n\n    public getViewMatrix(elapsedTime: number): Matrix4f {\n        const keyFrameDuration = 2600;\n\n        elapsedTime *= 1.0;\n\n        const first = ((elapsedTime / keyFrameDuration) | 0) % this.keyFrames.length;\n        const zero = ((first - 1) + this.keyFrames.length) % this.keyFrames.length;\n        const second = (first + 1) % this.keyFrames.length;\n        const third = (first + 2) % this.keyFrames.length;\n        const fraction = ((elapsedTime / keyFrameDuration) % this.keyFrames.length) - first;\n\n        const position = new Vector3f(\n            Utils.CubicInterpolate(this.keyFrames[zero].position.x, this.keyFrames[first].position.x, this.keyFrames[second].position.x, this.keyFrames[third].position.x, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].position.y, this.keyFrames[first].position.y, this.keyFrames[second].position.y, this.keyFrames[third].position.y, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].position.z, this.keyFrames[first].position.z, this.keyFrames[second].position.z, this.keyFrames[third].position.z, fraction)\n        );\n        //let look = this.keyFrames[first].rotation.mul(1 - mu2).add(this.keyFrames[second].rotation.mul(mu2));\n\n        const look = new Vector3f(\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.x, this.keyFrames[first].rotation.x, this.keyFrames[second].rotation.x, this.keyFrames[third].rotation.x, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.y, this.keyFrames[first].rotation.y, this.keyFrames[second].rotation.y, this.keyFrames[third].rotation.y, fraction),\n            Utils.CubicInterpolate(this.keyFrames[zero].rotation.z, this.keyFrames[first].rotation.z, this.keyFrames[second].rotation.z, this.keyFrames[third].rotation.z, fraction)\n        );\n        this.pos = position;\n\n        return new EulerAngleCamera(position, look.x, look.y, look.z).getViewMatrix();\n    }\n\n}\n\n","import { CameraKeyFrame } from '../../animation/CameraKeyFrame';\nimport { CameraLoader } from '../../camera/CameraLoader';\nimport { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { Matrix4f, Vector4f } from '../../math';\nimport { WavefrontLoader } from '../../model/wavefront-obj/WavefrontLoader';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { PointLight } from '../../shading/light/PointLight';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\n\nimport { BlenderCameraAnimator } from '../../animation/BlenderCameraAnimator';\nimport { SkyBox } from '../../SkyBox';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\n\nexport class BlenderCameraScene extends AbstractScene {\n\n    private texture4: Texture;\n    private fpsStartTime: number = Date.now();\n    private fpsCount: number = 0;\n    private fps: number = 0;\n\n    private meshes: Array<FlatshadedMesh>;\n    private path: Array<CameraKeyFrame>;\n    private skyBox: SkyBox;\n\n    private light1: PointLight;\n    private light2: PointLight;\n\n    private cameraAnimator: BlenderCameraAnimator;\n\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.renderingPipeline.setCullFace(CullFace.BACK);\n\n        this.light1 = new PointLight();\n        this.light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        this.light1.diffuseIntensity = new Vector4f(1, 0.0, 1, 1);\n        this.light1.specularIntensity = new Vector4f(0.5, 0.5, 0.7, 1);\n        this.light1.position = new Vector4f(0, -10, -1, 1);\n\n        this.light2 = new PointLight();\n        this.light2.ambientIntensity = new Vector4f(0.5, 0.5, 1, 1);\n        this.light2.diffuseIntensity = new Vector4f(0.3, 0.3, 1, 1);\n        this.light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        this.light2.position = new Vector4f(3, 0, -2, 1);\n\n        this.renderingPipeline.setLights([this.light1, this.light2]);\n\n        this.skyBox = new SkyBox();\n        return Promise.all([\n            this.skyBox.init(),\n            WavefrontLoader.load(require('../../assets/monkey.obj')).then(\n                (value: Array<FlatshadedMesh>) => this.meshes = value\n            ),\n            CameraLoader.load(require('../../assets/camera-path.jsx')).then(\n                (value: Array<CameraKeyFrame>) => this.path = value\n            ),\n            TextureUtils.load(require('../../assets/font.png'), true).then(\n                (texture: Texture) => this.texture4 = texture),\n        ]).then(() => {\n            this.cameraAnimator = new BlenderCameraAnimator();\n            this.cameraAnimator.setKeyFrames(this.path);\n        });\n    }\n\n    private computeFps(currentTime: number): void {\n        if (currentTime > this.fpsStartTime + 1000) {\n            this.fpsStartTime = currentTime;\n            this.fps = this.fpsCount;\n            this.fpsCount = 0;\n        }\n        this.fpsCount++;\n    }\n\n    public render(framebuffer: Framebuffer, timeInput: number): void {\n        const currentTime: number = Date.now();\n        this.computeFps(currentTime);\n\n        const modelViewMartrix: Matrix4f = this.cameraAnimator.getViewMatrix(timeInput);\n\n        this.skyBox.draw(framebuffer, modelViewMartrix);\n\n        framebuffer.clearDepthBuffer();\n        this.renderingPipeline.drawMeshArray(framebuffer, this.meshes, modelViewMartrix);\n\n        framebuffer.drawText(8, 8, 'FPS: ' + this.fps.toString(), this.texture4);\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { BlenderCameraScene } from '../../blender-camera-animation/BlenderCameraScene';\nexport class Scene9 {\n    private BlenderCameraScene: BlenderCameraScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.BlenderCameraScene = new BlenderCameraScene();\n\n        return Promise.all([\n            this.BlenderCameraScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        framebuffer.clearColorBuffer(0);\n        framebuffer.clearDepthBuffer();\n        this.BlenderCameraScene.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from './index';\nimport { Sphere } from './Sphere';\n\nexport class ComputationalGeometryUtils {\n\n    public computeBoundingSphere(vertices: Array<Vector4f>): Sphere {\n\n        if (vertices.length === 0) {\n            throw new Error('More than one vertex required.');\n        }\n\n        if (vertices.length === 1) {\n            return new Sphere(vertices[0], 0);\n        }\n\n        let center = new Vector4f(0, 0, 0, 0);\n        let radius = 0;\n\n        vertices.forEach(point => {\n            center = center.add(new Vector4f(point.x, point.y, point.z, 0.0));\n        });\n\n        center = center.mul(1.0 / vertices.length);\n\n        vertices.forEach(point => {\n            radius = Math.max(radius, center.sub(point).length());\n        });\n\n        return new Sphere(center, radius);\n    }\n\n}\n","import { BoundingVolume } from './BoundingVolume';\nimport { Vector4f } from './index';\nimport { Matrix4f } from './Matrix4f';\nimport { Plane } from './Plane';\n\nexport class Sphere implements BoundingVolume {\n\n    private center: Vector4f;\n    private radius: number;\n\n    public constructor(position: Vector4f, radius: number) {\n        this.center = position;\n        this.radius = radius;\n    }\n\n    /**\n     *\n     * @param {Plane} plane\n     * @returns {boolean}\n     * @memberof Sphere\n     */\n    public isInsidePositiveHalfSpace(plane: Plane): boolean {\n        return plane.getNormal().dot(this.center) - plane.getDistance() > - this.radius;\n    }\n\n    public getTran(mat: Matrix4f): Vector4f {\n        return mat.multiplyHom(this.center);\n    }\n\n    public getRadius(): number {\n        return this.radius;\n    }\n\n    public getCenter(): Vector4f {\n        return this.center;\n    }\n\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["SkyBox","back","down","front","left","right","up","texturedRenderingPipeline","init","Promise","all","load","then","texture","this","setClamp","draw","framebuffer","mv","setFramebuffer","drawSkyBox","getRotation","rotation","sclae","textures","camera","skyBoxSideModel","skyPoints","i","multiplyMatrix","constructXRotationMatrix","Math","PI","constructYRotationMatrix","constructScaleMatrix","points","points2","map","uv","faces","vertices","setTexture","setModelViewMatrix","BlenderJsonParser","static","blenderScene","invert","scene","forEach","object","Array","normals","v","push","x","y","z","mul","normalize","f","n1","n2","n3","v1","v2","v3","obj","transformedNormals","transformedPoints","file","disp","coords","u","add","sphere","computeBoundingSphere","getCenter","w","normals2","boundingSphere","name","CameraKeyFrame","position","constructor","CameraPath","frames","CameraFrame","frame","CameraLoader","filename","fetch","response","text","json","JSON","parse","cameraPath","keys","length","myFrame","Vector3f","location","Mesh","Vector","TexCoord","Face","convertToMeshArray","data","currentObject","normalCount","vertexCount","uvCount","normalOffset","vertexOffset","uvOffset","toString","split","line","startsWith","console","error","Error","vertex","Number","parseFloat","normal","face","WavefrontLoader","meshes","getBlenderScene","EulerAngleCamera","rx","ry","rz","getViewMatrix","Matrix4f","constructZRotationMatrix","translation","constructTranslationMatrix","getPosition","BlenderCameraAnimator","pos","keyFrames","setKeyFrames","elapsedTime","first","zero","second","third","fraction","Utils","CubicInterpolate","look","BlenderCameraScene","AbstractScene","texture4","fpsStartTime","Date","now","fpsCount","fps","path","skyBox","light1","light2","cameraAnimator","renderingPipeline","GouraudShadingRenderingPipeline","setCullFace","CullFace","BACK","PointLight","ambientIntensity","Vector4f","diffuseIntensity","specularIntensity","setLights","value","TextureUtils","computeFps","currentTime","render","timeInput","modelViewMartrix","clearDepthBuffer","drawMeshArray","drawText","Scene9","time","clearColorBuffer","ComputationalGeometryUtils","center","radius","point","max","sub","Sphere","isInsidePositiveHalfSpace","plane","getNormal","dot","getDistance","getTran","mat","multiplyHom","getRadius","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","r","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","super","fillLongRightTriangle","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","round","currentX","framebufferIndex","width","spanzStep","currentZ","wStart","j","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","vertexArray","ambientColor","diffuseColor","specularColor","shininess","setFog","enableLighting","enable","setMaterial","setColor","model","mesh","normalMatrix","computeNormalMatrix","multiplyHomArr","normal1","normal2","normal3","isInFrontOfNearPlane","project2","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","height","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","subject","input","S","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","scale","pow","Light","Material","emissiveColor"],"sourceRoot":""}