{"version":3,"file":"3554.js","mappings":"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","sources":["webpack://aisa/./src/SkyBox.ts","webpack://aisa/./src/blender/BlenderJsonParser.ts","webpack://aisa/./src/examples/baked-lighting/BakedLighting.ts","webpack://aisa/./src/examples/demo/parts/Scene15.ts","webpack://aisa/./src/math/Geometry.ts","webpack://aisa/./src/math/Sphere.ts","webpack://aisa/./src/model/blender/BlenderLoader.ts"],"sourcesContent":["import { Framebuffer } from './Framebuffer';\nimport { Matrix4f, Vector4f } from './math';\nimport { Texture, TextureUtils } from './texture';\nimport { TextureCoordinate } from './TextureCoordinate';\nimport { TexturingRenderingPipeline } from './rendering-pipelines/TexturingRenderingPipeline';\nimport { TexturedMesh } from './rendering-pipelines/TexturedMesh';\n\nexport class SkyBox {\n\n    private back: Texture;\n    private down: Texture;\n    private front: Texture;\n    private left: Texture;\n    private right: Texture;\n    private up: Texture;\n\n    private texturedRenderingPipeline: TexturingRenderingPipeline = new TexturingRenderingPipeline(null);\n    public init(): Promise<any> {\n\n        return Promise.all([\n            TextureUtils.load(require('@assets/skybox/skybox_back.png'), false).then(\n                (texture: Texture) => this.back = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_down.png'), false).then(\n                (texture: Texture) => this.down = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_front.png'), false).then(\n                (texture: Texture) => this.front = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_left.png'), false).then(\n                (texture: Texture) => this.left = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_right.png'), false).then(\n                (texture: Texture) => this.right = texture\n            ),\n            TextureUtils.load(require('@assets/skybox/skybox_up.png'), false).then(\n                (texture: Texture) => this.up = texture\n            )]).then(() => {\n                this.back.setClamp(true);\n                this.down.setClamp(true);\n                this.front.setClamp(true);\n                this.left.setClamp(true);\n                this.right.setClamp(true);\n                this.up.setClamp(true);\n            });\n    }\n\n    // move code from framebuffer into draw method!\n    public draw(framebuffer: Framebuffer, mv: Matrix4f): void {\n    \n        this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n        this.drawSkyBox(framebuffer, mv.getRotation());\n    }\n\n    public drawSkyBox(framebuffer: Framebuffer, rotation: Matrix4f): void {\n        const sclae = 20;\n        const textures = [\n            this.back,\n            this.left,\n            this.front,\n            this.right\n        ];\n\n        let camera: Matrix4f;\n        let mv: Matrix4f;\n        let skyBoxSideModel: TexturedMesh;\n\n        const skyPoints = [\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, -1, -1, 1)\n        ];\n\n        for (let i = 0; i < 4; i++) {\n            camera =\n                rotation.multiplyMatrix(\n                    Matrix4f.constructXRotationMatrix(Math.PI).multiplyMatrix(\n                        Matrix4f.constructYRotationMatrix(+ Math.PI * 2 / 4 * i)));\n\n\n            mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n\n            // skybox: starz\n            skyBoxSideModel = {\n                points: skyPoints,\n                points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n                uv: [\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 0),\n                ],\n                faces: [\n                    {\n                        vertices: [0, 1, 2],\n                        uv: [0, 1, 2]\n                    },\n                    {\n                        vertices: [3, 4, 5],\n                        uv: [3, 4, 5]\n                    }\n                ]\n            };\n\n            framebuffer.setTexture(textures[i]);\n            this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n            this.texturedRenderingPipeline.setModelViewMatrix(mv);\n            this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n        }\n\n        camera = rotation.multiplyMatrix(\n            Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                Matrix4f.constructYRotationMatrix(0)\n                    .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 4 * 1).multiplyMatrix(Matrix4f.constructXRotationMatrix(-Math.PI * 2 / 4)))\n            );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.up);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n\n        camera =\n            rotation.multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(0)\n                        .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 2).multiplyMatrix(Matrix4f.constructXRotationMatrix(Math.PI * 2 / 4)))\n\n                );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.down);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n    }\n\n}\n","import { FlatShadedFace } from '../geometrical-objects/FlatShadedFace';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { BlenderScene } from './BlenderScene';\nimport { Face } from './face';\nimport { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexturedMesh } from '../rendering-pipelines/TexturedMesh';\nimport { TextureCoordinate } from '../TextureCoordinate';\nimport { ComputationalGeometryUtils } from '../math/Geometry';\nimport { TexCoord } from './tex-coord';\n\nexport class BlenderJsonParser {\n\n    public static parse(blenderScene: BlenderScene, invert: boolean = false): Array<FlatshadedMesh> {\n        const scene: Array<FlatshadedMesh> = [];\n\n        blenderScene.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n\n            object.vertices.forEach((v: Vector) => {\n                points.push(new Vector4f(v.x, v.y, v.z).mul(1));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(\n                    invert ? new Vector4f(v.x, v.y, v.z).normalize().mul(-1) : new Vector4f(v.x, v.y, v.z).normalize()\n                );\n            });\n\n            const faces: Array<FlatShadedFace> = [];\n            object.faces.forEach((f: Face) => {\n                faces.push({\n                    n1: f.normals[0],\n                    n2: f.normals[1],\n                    n3: f.normals[2],\n                    v1: f.vertices[0],\n                    v2: f.vertices[1],\n                    v3: f.vertices[2],\n                });\n            });\n\n            const obj: FlatshadedMesh = {\n                faces,\n                normals,\n                points,\n                transformedNormals: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                transformedPoints: points.map(() => new Vector4f(0, 0, 0, 0)),\n            };\n\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n    public static getBlenderScene(\n        file: BlenderScene, disp: boolean = true): Array<TexturedMesh> {\n        const scene: Array<TexturedMesh> = [];\n\n        file.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n            let coords: Array<TextureCoordinate>;\n\n            if (object.uv) {\n                coords = [];\n                object.uv.forEach((v: TexCoord) => {\n                    const uv: TextureCoordinate = new TextureCoordinate();\n                    uv.u = v.u;\n                    uv.v = 1.0 - v.v;\n                    coords.push(uv);\n                });\n            }\n\n            object.vertices.forEach((v: Vector) => {\n                // some transformation in order for the vertices to be in worldspace\n                if (disp)\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2).add(new Vector4f(0, -2.7, 0, 0)));\n                else\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(new Vector4f(v.x, v.y, v.z));\n            });\n\n            const sphere = new ComputationalGeometryUtils().computeBoundingSphere(points);\n            sphere.getCenter().w = 1;\n\n            // Create class for objects\n            const obj = {\n                points,\n                normals,\n                uv: coords,           // NO!!!\n                faces: object.faces, // NOO!!!\n                points2: points.map(() => new Vector4f(0, 0, 0, 0)),\n                normals2: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                boundingSphere: sphere, // NO!!!\n                name: object.name /// NO!\n            };\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n}\n","import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Matrix4f } from '../../math/Matrix4f';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { SkyBox } from '../../SkyBox';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\nimport { BlenderLoader } from '../../model/blender/BlenderLoader';\nimport { TexturingRenderingPipeline } from '../../rendering-pipelines/TexturingRenderingPipeline';\n\n/**\n * TODO:\n * - Move procedural texture generation into dedicated class\n * - create Mesh / Textured Mesh class\n * - Create Lens Flare class\n * - Create Pipeline class\n */\nexport class BakedLighting extends AbstractScene {\n\n    private skyBox: SkyBox;\n    private baked: Texture;\n    private noise: Texture;\n    private blenderObj8: Array<TexturedMesh>;\n    private accumulationBuffer: Uint32Array;\n    private texturedRenderingPipeline: TexturingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.texturedRenderingPipeline = new TexturingRenderingPipeline(framebuffer);\n        this.accumulationBuffer = new Uint32Array(framebuffer.width * framebuffer.height);\n        framebuffer.setCullFace(CullFace.BACK);\n        this.skyBox = new SkyBox();\n\n        return Promise.all([\n            this.skyBox.init(),\n            BlenderLoader.loadWithTexture(require('@assets/jsx/abstract.jsx')).then(\n                (mesh: Array<TexturedMesh>) => this.blenderObj8 = mesh\n            ),\n            TextureUtils.load(require('@assets/Backed.png'), false).then(\n                (texture: Texture) => this.baked = texture\n            ),\n            TextureUtils.generateProceduralNoise().then(\n                (texture: Texture) => this.noise = texture\n            ),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n\n        this.texturedRenderingPipeline.setCullFace(CullFace.BACK);\n\n        this.drawBlenderScene7(framebuffer, time - 1100000);\n        /*\n            [\n                //   { tex: this.texture10, scale: 0.0, alpha: 1.0 },\n                { tex: this.texture11, scale: 2.3, alpha: 0.5 },\n                { tex: this.texture13, scale: 1.6, alpha: 0.25 },\n                { tex: this.texture13, scale: 0.7, alpha: 0.22 },\n                { tex: this.texture13, scale: -0.4, alpha: 0.22 },\n            ], this.dirt, this.skybox);*/\n\n        const texture3: Texture = new Texture(this.accumulationBuffer, framebuffer.width, framebuffer.height);\n        framebuffer.drawTexture(0, 0, texture3, 0.75);\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n        framebuffer.noise(time, this.noise);\n    }\n\n    public drawBlenderScene7(framebuffer: Framebuffer, elapsedTime: number): void {\n        elapsedTime *= 0.2;\n        framebuffer.clearDepthBuffer();\n\n        const camera: Matrix4f =\n            Matrix4f.constructTranslationMatrix(0, 0, -134 + (Math.sin(elapsedTime * 0.00007) * 0.5 + 0.5) * 17).multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(elapsedTime * 0.0006).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(-elapsedTime * 0.0005).multiplyMatrix(\n                        Matrix4f.constructTranslationMatrix(0, -25, 0)\n                    )));\n\n        const mv: Matrix4f = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(13, 13, 13));\n\n        this.skyBox.draw(framebuffer, mv);\n\n        framebuffer.clearDepthBuffer();\n        framebuffer.setTexture(this.baked);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.drawMeshArray(framebuffer, this.blenderObj8);\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { BakedLighting } from '../../baked-lighting/BakedLighting';\n\nexport class Scene15 {\n    private BakedLighting: BakedLighting;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.BakedLighting = new BakedLighting();\n\n        return Promise.all([\n            this.BakedLighting.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.BakedLighting.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from './index';\nimport { Sphere } from './Sphere';\n\nexport class ComputationalGeometryUtils {\n\n    public computeBoundingSphere(vertices: Array<Vector4f>): Sphere {\n\n        if (vertices.length === 0) {\n            throw new Error('More than one vertex required.');\n        }\n\n        if (vertices.length === 1) {\n            return new Sphere(vertices[0], 0);\n        }\n\n        let center = new Vector4f(0, 0, 0, 0);\n        let radius = 0;\n\n        vertices.forEach(point => {\n            center = center.add(new Vector4f(point.x, point.y, point.z, 0.0));\n        });\n\n        center = center.mul(1.0 / vertices.length);\n\n        vertices.forEach(point => {\n            radius = Math.max(radius, center.sub(point).length());\n        });\n\n        return new Sphere(center, radius);\n    }\n\n}\n","import { BoundingVolume } from './BoundingVolume';\nimport { Vector4f } from './index';\nimport { Matrix4f } from './Matrix4f';\nimport { Plane } from './Plane';\n\nexport class Sphere implements BoundingVolume {\n\n    private center: Vector4f;\n    private radius: number;\n\n    public constructor(position: Vector4f, radius: number) {\n        this.center = position;\n        this.radius = radius;\n    }\n\n    /**\n     *\n     * @param {Plane} plane\n     * @returns {boolean}\n     * @memberof Sphere\n     */\n    public isInsidePositiveHalfSpace(plane: Plane): boolean {\n        return plane.getNormal().dot(this.center) - plane.getDistance() > - this.radius;\n    }\n\n    public getTran(mat: Matrix4f): Vector4f {\n        return mat.multiplyHom(this.center);\n    }\n\n    public getRadius(): number {\n        return this.radius;\n    }\n\n    public getCenter(): Vector4f {\n        return this.center;\n    }\n\n}\n","import { BlenderJsonParser } from '../../blender/BlenderJsonParser';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { BlenderScene } from '../../blender/BlenderScene';\n\n/**\n * Load Wavefront OBJ file that was converted via obj2json utility.\n * to save the convertToMeshArray step\n * renamed to JSX file to load file at runtime\n */\nexport class BlenderLoader {\n\n    public static load(filename: string): Promise<Array<FlatshadedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.parse(meshes);\n        });\n    }\n\n    public static loadWithTexture(filename: string): Promise<Array<TexturedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.getBlenderScene(meshes, false);\n        });\n    }\n\n    private constructor() {\n\n    }\n}\n"],"names":["SkyBox","back","down","front","left","right","up","texturedRenderingPipeline","init","Promise","all","load","then","texture","this","setClamp","draw","framebuffer","mv","setFramebuffer","drawSkyBox","getRotation","rotation","sclae","textures","camera","skyBoxSideModel","skyPoints","i","multiplyMatrix","constructXRotationMatrix","Math","PI","constructYRotationMatrix","constructScaleMatrix","points","points2","map","uv","faces","vertices","setTexture","setModelViewMatrix","BlenderJsonParser","parse","blenderScene","invert","scene","forEach","object","Array","normals","v","push","x","y","z","mul","normalize","f","n1","n2","n3","v1","v2","v3","obj","transformedNormals","transformedPoints","getBlenderScene","file","disp","coords","u","add","sphere","computeBoundingSphere","getCenter","w","normals2","boundingSphere","name","BakedLighting","AbstractScene","skyBox","baked","noise","blenderObj8","accumulationBuffer","TexturingRenderingPipeline","Uint32Array","width","height","setCullFace","CullFace","BACK","BlenderLoader","loadWithTexture","mesh","TextureUtils","generateProceduralNoise","render","time","drawBlenderScene7","texture3","Texture","drawTexture","fastFramebufferCopy","elapsedTime","clearDepthBuffer","Matrix4f","constructTranslationMatrix","sin","drawMeshArray","Scene15","ComputationalGeometryUtils","length","Error","center","radius","point","max","sub","Sphere","position","isInsidePositiveHalfSpace","plane","getNormal","dot","getDistance","getTran","mat","multiplyHom","getRadius","filename","fetch","response","json","meshes"],"sourceRoot":""}