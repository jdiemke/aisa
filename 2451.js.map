{"version":3,"file":"2451.js","mappings":"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","sources":["webpack://aisa/./src/blender/BlenderJsonParser.ts","webpack://aisa/./src/examples/hoodlum/HoodlumScene.ts","webpack://aisa/./src/examples/demo/parts/Scene17.ts","webpack://aisa/./src/math/Geometry.ts","webpack://aisa/./src/math/Sphere.ts","webpack://aisa/./src/model/blender/BlenderLoader.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { FlatShadedFace } from '../geometrical-objects/FlatShadedFace';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { BlenderScene } from './BlenderScene';\nimport { Face } from './face';\nimport { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexturedMesh } from '../rendering-pipelines/TexturedMesh';\nimport { TextureCoordinate } from '../TextureCoordinate';\nimport { ComputationalGeometryUtils } from '../math/Geometry';\nimport { TexCoord } from './tex-coord';\n\nexport class BlenderJsonParser {\n\n    public static parse(blenderScene: BlenderScene, invert: boolean = false): Array<FlatshadedMesh> {\n        const scene: Array<FlatshadedMesh> = [];\n\n        blenderScene.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n\n            object.vertices.forEach((v: Vector) => {\n                points.push(new Vector4f(v.x, v.y, v.z).mul(1));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(\n                    invert ? new Vector4f(v.x, v.y, v.z).normalize().mul(-1) : new Vector4f(v.x, v.y, v.z).normalize()\n                );\n            });\n\n            const faces: Array<FlatShadedFace> = [];\n            object.faces.forEach((f: Face) => {\n                faces.push({\n                    n1: f.normals[0],\n                    n2: f.normals[1],\n                    n3: f.normals[2],\n                    v1: f.vertices[0],\n                    v2: f.vertices[1],\n                    v3: f.vertices[2],\n                });\n            });\n\n            const obj: FlatshadedMesh = {\n                faces,\n                normals,\n                points,\n                transformedNormals: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                transformedPoints: points.map(() => new Vector4f(0, 0, 0, 0)),\n            };\n\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n    public static getBlenderScene(\n        file: BlenderScene, disp: boolean = true): Array<TexturedMesh> {\n        const scene: Array<TexturedMesh> = [];\n\n        file.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n            let coords: Array<TextureCoordinate>;\n\n            if (object.uv) {\n                coords = [];\n                object.uv.forEach((v: TexCoord) => {\n                    const uv: TextureCoordinate = new TextureCoordinate();\n                    uv.u = v.u;\n                    uv.v = 1.0 - v.v;\n                    coords.push(uv);\n                });\n            }\n\n            object.vertices.forEach((v: Vector) => {\n                // some transformation in order for the vertices to be in worldspace\n                if (disp)\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2).add(new Vector4f(0, -2.7, 0, 0)));\n                else\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(new Vector4f(v.x, v.y, v.z));\n            });\n\n            const sphere = new ComputationalGeometryUtils().computeBoundingSphere(points);\n            sphere.getCenter().w = 1;\n\n            // Create class for objects\n            const obj = {\n                points,\n                normals,\n                uv: coords,           // NO!!!\n                faces: object.faces, // NOO!!!\n                points2: points.map(() => new Vector4f(0, 0, 0, 0)),\n                normals2: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                boundingSphere: sphere, // NO!!!\n                name: object.name /// NO!\n            };\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n}\n","import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Matrix4f, Vector3f } from '../../math';\nimport RandomNumberGenerator from '../../RandomNumberGenerator';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Texture, TextureUtils } from '../../texture';\nimport { BlenderLoader } from './../../model/blender/BlenderLoader';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturingRenderingPipeline } from '../../rendering-pipelines/TexturingRenderingPipeline';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\nimport { Interpolator } from '../../math/Interpolator';\n\nexport class HoodlumScene extends AbstractScene {\n\n    private blurred: Texture;\n    private lab2: Texture;\n    private noise: Texture;\n    private particleTexture2: Texture;\n    private spaceLabMesh: Array<TexturedMesh>;\n    private hoodlumLogoMesh: Array<FlatshadedMesh>;\n    private accumulationBuffer: Uint32Array;\n\n    private texturedRenderingPipeline: TexturingRenderingPipeline;\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.texturedRenderingPipeline = new TexturingRenderingPipeline(framebuffer);\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.accumulationBuffer = new Uint32Array(framebuffer.width * framebuffer.height);\n        return Promise.all([\n            TextureUtils.load(require('../../assets/blurredBackground.png'), false).then(\n                (texture: Texture) => this.blurred = texture\n            ),\n            BlenderLoader.loadWithTexture(require('../../assets/jsx/lab2.jsx')).then(\n                (mesh: Array<TexturedMesh>) => this.spaceLabMesh = mesh\n            ),\n            BlenderLoader.load(require('../../assets/jsx/hoodlum2018.jsx')).then(\n                (mesh: Array<FlatshadedMesh>) => this.hoodlumLogoMesh = mesh\n            ),\n            TextureUtils.load(require('../../assets/lab2.png'), false).then(texture => this.lab2 = texture),\n            TextureUtils.generateProceduralNoise().then(texture => this.noise = texture),\n            this.createProceduralTexture3().then(texture => this.particleTexture2 = texture),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.texturedRenderingPipeline.setCullFace(CullFace.BACK);\n        framebuffer.setCullFace(CullFace.BACK);\n\n        // framebuffer.fastFramebufferCopy(framebuffer.framebuffer, this.blurred.texture);\n        framebuffer.drawScaledTextureClipBi(0,0,framebuffer.width, framebuffer.height, this.blurred, 1.0);\n        framebuffer.setCullFace(CullFace.BACK);\n        framebuffer.setTexture(this.lab2);\n\n        this.drawBlenderScene9(framebuffer, time, this.particleTexture2);\n\n        const texture3: Texture = new Texture(this.accumulationBuffer, framebuffer.width, framebuffer.height);\n        framebuffer.drawTexture(0, 0, texture3, 0.75);\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n\n        framebuffer.noise(time, this.noise);\n    }\n\n    public drawBlenderScene9(framebuffer: Framebuffer, elapsedTime: number, texture3: Texture): void {\n        framebuffer.clearDepthBuffer();\n\n        const camera: Matrix4f =\n            Matrix4f.constructTranslationMatrix(0, 0, -34 + (Math.sin(elapsedTime * 0.00007) * 0.5 + 0.5) * 7).multiplyMatrix(\n                Matrix4f.constructXRotationMatrix((Math.sin(elapsedTime * 0.00014) * 0.5 + 0.5) * 0.5 - 0.2).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(-elapsedTime * 0.0002).multiplyMatrix(\n                        Matrix4f.constructTranslationMatrix(0, 1.9, 0)\n                    )));\n\n        let mv: Matrix4f = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(13, 13, 13));\n\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.drawMeshArray(framebuffer, this.spaceLabMesh);\n\n        mv = camera.multiplyMatrix(\n            Matrix4f.constructTranslationMatrix(0, -5.5, 0).multiplyMatrix(\n                Matrix4f.constructScaleMatrix(413, 413, 413).multiplyMatrix(\n                    Matrix4f.constructXRotationMatrix(Math.PI * 0.5)\n                )\n            ));\n\n        const model = this.hoodlumLogoMesh[0];\n        this.renderingPipeline.draw(framebuffer, model, mv);\n\n        const points: Array<Vector3f> = new Array<Vector3f>();\n        const num = 10;\n        const num2 = 6;\n\n        for (let i = 0; i < num; i++) {\n\n            for (let j = 0; j < num2; j++) {\n                const y = ((i + elapsedTime * 0.001) % 10) * 2.5 - 12;\n                const scale2 = (1 + 4 * Interpolator.interpolate(-10, 10, y)) *\n\n                    ((Math.sin(elapsedTime * 0.0012 + Math.PI * 2 / num * i * 2) * 0.5 + 0.5) * 0.5 + 0.5);\n                const x = scale2 * Math.sin(Math.PI * 2 / num2 * j + elapsedTime * 0.0008);\n\n                const z = scale2 * Math.cos(Math.PI * 2 / num2 * j + elapsedTime * 0.0008);\n\n                points.push(new Vector3f(x, y, z));\n            }\n        }\n\n        const modelViewMartrix = camera.multiplyMatrix(Matrix4f.constructTranslationMatrix(0, -0.0, 0));\n\n        const points2: Array<Vector3f> = new Array<Vector3f>(points.length);\n\n        points.forEach(element => {\n            const transformed = framebuffer.project(modelViewMartrix.multiply(element));\n            points2.push(transformed);\n        });\n\n        points2.sort((a, b) => {\n            return a.z - b.z;\n        });\n\n        points2.forEach(element => {\n            const size = -(4.3 * 192 / (element.z));\n            framebuffer.drawSoftParticle(\n                Math.round(element.x - size / 2),\n                Math.round(element.y - size / 2),\n                Math.round(size), Math.round(size), texture3, 1 / element.z, 0.7);\n        });\n    }\n\n    public createProceduralTexture3(): Promise<Texture> {\n        return new Promise((resolve) => {\n            const texture = new Texture();\n            texture.texture = new Uint32Array(256 * 256);\n\n            const rng = new RandomNumberGenerator();\n            rng.setSeed(100);\n\n            for (let y = 0; y < 256; y++) {\n                for (let x = 0; x < 256; x++) {\n                    const dx = 127 - x\n                    const dy = 127 - y\n                    const r = Math.sqrt(dx * dx + dy * dy) / 127;\n                    let c = 1 - r;\n                    c = c * c * c;\n                    if (r > 1) c = 0;\n                    c = Math.min(1, c * 2.9);\n\n                    texture.texture[x + y * 256] = 235 | 255 << 8 | 235 << 16 | (c * 255) << 24;\n                }\n            }\n\n            texture.width = 256;\n            texture.height = 256;\n            resolve(texture);\n        });\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { HoodlumScene } from '../../hoodlum/HoodlumScene';\n\nexport class Scene17 {\n    private HoodlumScene: HoodlumScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.HoodlumScene = new HoodlumScene();\n\n        return Promise.all([\n            this.HoodlumScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.HoodlumScene.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from './index';\nimport { Sphere } from './Sphere';\n\nexport class ComputationalGeometryUtils {\n\n    public computeBoundingSphere(vertices: Array<Vector4f>): Sphere {\n\n        if (vertices.length === 0) {\n            throw new Error('More than one vertex required.');\n        }\n\n        if (vertices.length === 1) {\n            return new Sphere(vertices[0], 0);\n        }\n\n        let center = new Vector4f(0, 0, 0, 0);\n        let radius = 0;\n\n        vertices.forEach(point => {\n            center = center.add(new Vector4f(point.x, point.y, point.z, 0.0));\n        });\n\n        center = center.mul(1.0 / vertices.length);\n\n        vertices.forEach(point => {\n            radius = Math.max(radius, center.sub(point).length());\n        });\n\n        return new Sphere(center, radius);\n    }\n\n}\n","import { BoundingVolume } from './BoundingVolume';\nimport { Vector4f } from './index';\nimport { Matrix4f } from './Matrix4f';\nimport { Plane } from './Plane';\n\nexport class Sphere implements BoundingVolume {\n\n    private center: Vector4f;\n    private radius: number;\n\n    public constructor(position: Vector4f, radius: number) {\n        this.center = position;\n        this.radius = radius;\n    }\n\n    /**\n     *\n     * @param {Plane} plane\n     * @returns {boolean}\n     * @memberof Sphere\n     */\n    public isInsidePositiveHalfSpace(plane: Plane): boolean {\n        return plane.getNormal().dot(this.center) - plane.getDistance() > - this.radius;\n    }\n\n    public getTran(mat: Matrix4f): Vector4f {\n        return mat.multiplyHom(this.center);\n    }\n\n    public getRadius(): number {\n        return this.radius;\n    }\n\n    public getCenter(): Vector4f {\n        return this.center;\n    }\n\n}\n","import { BlenderJsonParser } from '../../blender/BlenderJsonParser';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { BlenderScene } from '../../blender/BlenderScene';\n\n/**\n * Load Wavefront OBJ file that was converted via obj2json utility.\n * to save the convertToMeshArray step\n * renamed to JSX file to load file at runtime\n */\nexport class BlenderLoader {\n\n    public static load(filename: string): Promise<Array<FlatshadedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.parse(meshes);\n        });\n    }\n\n    public static loadWithTexture(filename: string): Promise<Array<TexturedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.getBlenderScene(meshes, false);\n        });\n    }\n\n    private constructor() {\n\n    }\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["BlenderJsonParser","parse","blenderScene","invert","scene","forEach","object","points","Array","normals","vertices","v","push","x","y","z","mul","normalize","faces","f","n1","n2","n3","v1","v2","v3","obj","transformedNormals","map","transformedPoints","getBlenderScene","file","disp","coords","uv","u","add","sphere","computeBoundingSphere","getCenter","w","points2","normals2","boundingSphere","name","HoodlumScene","AbstractScene","blurred","lab2","noise","particleTexture2","spaceLabMesh","hoodlumLogoMesh","accumulationBuffer","texturedRenderingPipeline","renderingPipeline","init","framebuffer","this","TexturingRenderingPipeline","GouraudShadingRenderingPipeline","Uint32Array","width","height","Promise","all","TextureUtils","load","then","texture","BlenderLoader","loadWithTexture","mesh","generateProceduralNoise","createProceduralTexture3","render","time","setCullFace","CullFace","BACK","drawScaledTextureClipBi","setTexture","drawBlenderScene9","texture3","Texture","drawTexture","fastFramebufferCopy","elapsedTime","clearDepthBuffer","camera","Matrix4f","constructTranslationMatrix","Math","sin","multiplyMatrix","constructXRotationMatrix","constructYRotationMatrix","mv","constructScaleMatrix","setModelViewMatrix","drawMeshArray","PI","model","draw","i","j","scale2","Interpolator","interpolate","cos","Vector3f","modelViewMartrix","length","element","transformed","project","multiply","sort","a","b","size","drawSoftParticle","round","resolve","RandomNumberGenerator","setSeed","dx","dy","r","sqrt","c","min","Scene17","ComputationalGeometryUtils","Error","center","radius","point","max","sub","Sphere","position","isInsidePositiveHalfSpace","plane","getNormal","dot","getDistance","getTran","mat","multiplyHom","getRadius","filename","fetch","response","json","meshes","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","g","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","constructor","super","fillLongRightTriangle","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","currentX","framebufferIndex","spanzStep","currentZ","wStart","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","light2","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setFog","setLights","enableLighting","enable","setMaterial","setColor","normalMatrix","computeNormalMatrix","multiplyHomArr","normal1","normal2","normal3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","vertex","subject","input","S","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","scale","pow","Light","PointLight","Material","emissiveColor"],"sourceRoot":""}