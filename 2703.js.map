{"version":3,"file":"2703.js","mappings":"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","sources":["webpack://aisa/./src/examples/torus/TorusScene.ts","webpack://aisa/./src/examples/demo/parts/Scene5.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Torus } from '../../geometrical-objects/Torus';\nimport { Matrix4f } from '../../math/Matrix4f';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\n\nexport class TorusScene extends AbstractScene {\n\n    private razorLogo: Texture;\n    private torus: Torus = new Torus();\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.renderingPipeline.setCullFace(CullFace.BACK);\n\n        return Promise.all([\n            TextureUtils.load(require('./assets/razor1911.png'), true).then(\n                (texture: Texture) => this.razorLogo = texture\n            )\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n\n        this.drawTitanEffect(framebuffer, time);\n        this.shadingTorus(framebuffer, time * 0.02);\n        framebuffer.drawTexture(framebuffer.width / 2 - this.razorLogo.width / 2, 0, this.razorLogo, 1.0);\n    }\n\n    public shadingTorus(framebuffer: Framebuffer, elapsedTime: number): void {\n        framebuffer.clearDepthBuffer();\n\n        let modelViewMartrix: Matrix4f = Matrix4f.constructYRotationMatrix(elapsedTime * 0.05);\n        modelViewMartrix = modelViewMartrix.multiplyMatrix(Matrix4f.constructXRotationMatrix(elapsedTime * 0.08));\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(0, 0, -24).multiplyMatrix(modelViewMartrix);\n\n        this.renderingPipeline.draw(framebuffer, this.torus.getMesh(), modelViewMartrix);\n    }\n\n\n    private drawTitanEffect(framebuffer: Framebuffer, time: number) {\n        framebuffer.clear();\n        const horizontalNum = framebuffer.width / 20;\n        const verticalNum = framebuffer.height / 20;\n\n        for (let x = 0; x < horizontalNum; x++) {\n            for (let y = 0; y < verticalNum; y++) {\n\n                const scale = ((Math.sin(time * 0.004 + x * 0.7 + y * 0.4) + 1) / 2);\n                const size = Math.round(scale * 8 + 1) * 2;\n                const offset = (20 / 2 - size / 2) | 0;\n                const color = 255 << 24 | (85 * scale) << 16 | (55 * scale) << 8 | (55 * scale);\n                framebuffer.drawBox2(x * 20 + offset, y * 20 + offset, size, size, color);\n            }\n        }\n\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { TorusScene } from '../../torus/TorusScene';\n\nexport class Scene5 {\n    private TorusScene: TorusScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.TorusScene = new TorusScene();\n\n        return Promise.all([\n            this.TorusScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.TorusScene.render(framebuffer, time);\n    }\n\n}","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["TorusScene","AbstractScene","razorLogo","torus","Torus","renderingPipeline","init","framebuffer","this","GouraudShadingRenderingPipeline","setCullFace","CullFace","BACK","Promise","all","TextureUtils","load","then","texture","render","time","drawTitanEffect","shadingTorus","drawTexture","width","elapsedTime","clearDepthBuffer","modelViewMartrix","Matrix4f","constructYRotationMatrix","multiplyMatrix","constructXRotationMatrix","constructTranslationMatrix","draw","getMesh","clear","horizontalNum","verticalNum","height","x","y","scale","Math","sin","size","round","offset","color","drawBox2","Scene5","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","r","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","constructor","super","fillLongRightTriangle","v1","v2","v3","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","i","length","currentX","framebufferIndex","spanzStep","currentZ","wStart","j","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","z","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","Array","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","position","light2","mat","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setFog","setLights","enableLighting","enable","setMaterial","setColor","drawMeshArray","meshes","model","mesh","normalMatrix","computeNormalMatrix","normals","multiplyHomArr","transformedNormals","points","transformedPoints","faces","normal1","n1","normal2","n2","normal3","n3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","vertex","sub","mul","add","subject","input","S","point","push","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","normalize","max","dot","v","pow","Light","PointLight","Material","emissiveColor"],"sourceRoot":""}