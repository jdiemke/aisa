{"version":3,"file":"3688.js","mappings":"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","sources":["webpack://aisa/./src/examples/voxel-balls/VoxelBallsScene.ts","webpack://aisa/./src/examples/led-plasma/LedPlasmaScene.ts","webpack://aisa/./src/examples/demo/parts/Scene8.ts","webpack://aisa/./src/geometrical-objects/Cube.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { Color } from '../../core/Color';\nimport { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Cube } from '../../geometrical-objects/Cube';\nimport { Matrix4f } from '../../math';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { TextureUtils, Texture } from '../../texture/index';\n\n/**\n * TODO: use cube mesh and draw using drawObject2\n */\nexport class VoxelBallsScene extends AbstractScene {\n\n    private static BACKGROUND_COLOR: number = Color.YELLOW.toPackedFormat();\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n    private cubeMesh: Cube = new Cube();\n    private blurred: Texture;\n    private accumulationBuffer: Uint32Array;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.accumulationBuffer = new Uint32Array(framebuffer.width * framebuffer.height);\n        framebuffer.setCullFace(CullFace.BACK);\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        return Promise.all([\n            TextureUtils.load(require('@assets/blurredBackground.png'), false).then(\n                (texture: Texture) => this.blurred = texture\n            )\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        framebuffer.fastFramebufferCopy(framebuffer.framebuffer, this.blurred.texture);\n        this.renderTransparent(framebuffer, time);\n        const texture3: Texture = new Texture(this.accumulationBuffer, framebuffer.width, framebuffer.height);\n        framebuffer.drawTextureFullscreen(texture3, 0.75);\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n    }\n\n    public renderTransparent(framebuffer: Framebuffer, time: number): void {\n\n        framebuffer.clearDepthBuffer();\n\n        const xSteps = 5;\n        const xsteps = 5;\n        const zsteps = 5;\n        for (let x = 0; x < xSteps; x++) {\n            for (let y = 0; y < xsteps; y++) {\n                for (let z = 0; z < zsteps; z++) {\n                    let scale = (Math.sin(x * 0.3 + time * 0.0009) + 1.0) * 0.5 *\n                        (Math.sin(y * 0.4 + time * 0.002) + 1.0) * 0.5 *\n                        (Math.sin(z * 0.3 + time * 0.001) + 1.0) * 0.5;\n                    if (scale < 0.3) {\n                        // continue;\n                    }\n                    scale = 0.8;\n                    const mat =\n                        Matrix4f.constructTranslationMatrix(0, 0, -11).multiplyMatrix(\n                            Matrix4f.constructYRotationMatrix(time * 0.0003).multiplyMatrix(\n                                Matrix4f.constructXRotationMatrix(time * 0.0005).multiplyMatrix(\n                                    Matrix4f.constructZRotationMatrix(time * 0.0004).multiplyMatrix(\n                                        Matrix4f.constructTranslationMatrix(x - xSteps / 2 + 0.5, y - xsteps / 2 + 0.5, z - zsteps / 2 + 0.5)\n                                            .multiplyMatrix(\n                                                Matrix4f.constructScaleMatrix(scale, scale, scale)))))); // .multiplyMatrix(\n                    //       Matrix4f.constructYRotationMatrix(elapsedTime * 0.05)).multiplyMatrix(\n                    //           Matrix4f.constructXRotationMatrix(elapsedTime * 0.08)));\n\n                    this.renderingPipeline.draw(framebuffer, this.cubeMesh.getMesh(), mat);\n                }\n            }\n        }\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n    }\n\n\n\n}\n","import { Framebuffer } from '../../Framebuffer';\nimport { Vector3f } from '../../math/Vector3f';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\n\n/**\n * TODO: extract lens into effect class\n */\nexport class LedPlasmaScene extends AbstractScene {\n\n    private ledTexture: Texture;\n\n    public init(): Promise<any> {\n        return Promise.all([\n            TextureUtils.load(require('@assets/led.png'), false).then(\n                (texture: Texture) => this.ledTexture = texture\n            ),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.led(framebuffer, time, this.ledTexture);\n    }\n\n    // TODO: create interesting pattern!\n    public led(framebuffer: Framebuffer, elapsedTime: number, texture: Texture): void {\n        const time = elapsedTime * 0.0007 * 1.0;\n        const lineDirection = new Vector3f(Math.sin(time), Math.cos(time), 0);\n        const radialWaveCenter = new Vector3f(40.0 / 2.0, 35.0 / 2.0, 0).add(new Vector3f(40.0 / 2.0 *\n            Math.sin(-time * 1.2), 35.0 / 2.0 * Math.cos(-time * 1.2), 0));\n        const difference: Vector3f = new Vector3f(0, 0, 0);\n\n        const horizontalUnits = Math.ceil(framebuffer.width / 8);\n        const verticalUnits = Math.ceil(framebuffer.height / 8);\n\n        for (let y = 0; y < verticalUnits; y++) {\n            for (let x = 0; x < horizontalUnits; x++) {\n                const directionalWave = (Math.sin((x * lineDirection.x + y * lineDirection.y) * 0.8 + time) + 1.0) * 0.5;\n                difference.x = x - radialWaveCenter.x;\n                difference.y = y - radialWaveCenter.y;\n                const radialWave = (Math.cos(difference.length() * 0.7) + 1.0) * 0.5;\n                const waveSum: number = (radialWave + directionalWave) * 0.5;\n\n                const intensity = ((waveSum * 15) | 0) % 16;\n                framebuffer.drawTextureRectNoAlpha(x * 8, y * 8, 0, 8 * intensity, 8, 8, texture);\n            }\n        }\n    }\n\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { VoxelBallsScene } from '../../voxel-balls/VoxelBallsScene';\nimport { LedPlasmaScene } from '../../led-plasma/LedPlasmaScene';\nimport { Texture } from '../../../texture/Texture';\nimport { TextureUtils } from '../../../texture/TextureUtils';\n\nexport class Scene8 {\n    private VoxelBallsScene: VoxelBallsScene;\n    private LedPlasmaScene: LedPlasmaScene;\n    private logo: Texture;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.VoxelBallsScene = new VoxelBallsScene();\n        this.LedPlasmaScene = new LedPlasmaScene();\n\n        return Promise.all([\n            this.LedPlasmaScene.init(),\n            this.VoxelBallsScene.init(framebuffer),\n            // pngitem.com/middle/Tommih_happy-surprised-woman-surprised-girl-png-transparent-png/\n            TextureUtils.load(require('@assets/logos/drug-chick.png'), true).then(\n                (texture: Texture) => this.logo = texture\n            ),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.LedPlasmaScene.render(framebuffer, time);\n        this.VoxelBallsScene.renderTransparent(framebuffer, time);\n        // framebuffer.drawTexture(0, ((framebuffer.height / 2) - (this.logo.height / 2)) | 0, this.logo, 1.0);\n\n    }\n\n}","import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class Cube extends AbstractGeometricObject {\n\n    public constructor() {\n        super();\n        const a: number = 0.5;\n\n        const points: Array<Vector4f> = [\n            new Vector4f(-a, -a, -a),\n            new Vector4f(a, -a, -a),\n            new Vector4f(a, a, -a),\n            new Vector4f(-a, a, -a),\n            new Vector4f(-a, -a, a),\n            new Vector4f(a, -a, a),\n            new Vector4f(a, a, a),\n            new Vector4f(-a, a, a)\n        ];\n\n        const index: Array<number> = [\n            0, 2, 1, 0, 3, 2, 5, 7, 4, 5, 6, 7, 1, 6, 5, 1, 2, 6, 4, 3, 0, 4, 7, 3, 4, 1, 5, 4, 0, 1, 3, 6, 2, 3, 7, 6\n        ];\n\n        this.buildMesh(points, index);\n    }\n\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["VoxelBallsScene","AbstractScene","static","Color","YELLOW","toPackedFormat","renderingPipeline","cubeMesh","Cube","blurred","accumulationBuffer","init","framebuffer","this","Uint32Array","width","height","setCullFace","CullFace","BACK","GouraudShadingRenderingPipeline","Promise","all","TextureUtils","load","then","texture","render","time","fastFramebufferCopy","renderTransparent","texture3","Texture","drawTextureFullscreen","clearDepthBuffer","x","y","z","scale","Math","sin","mat","Matrix4f","constructTranslationMatrix","multiplyMatrix","constructYRotationMatrix","constructXRotationMatrix","constructZRotationMatrix","xSteps","xsteps","zsteps","constructScaleMatrix","draw","getMesh","LedPlasmaScene","ledTexture","led","elapsedTime","lineDirection","Vector3f","cos","radialWaveCenter","add","difference","horizontalUnits","ceil","verticalUnits","directionalWave","intensity","length","drawTextureRectNoAlpha","Scene8","logo","super","a","points","buildMesh","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","r","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","constructor","fillLongRightTriangle","v1","v2","v3","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","i","round","currentX","framebufferIndex","spanzStep","currentZ","wStart","j","wBuffer","SlopeInterpolator","slope","zslope","top","bottom","projection","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","Array","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","position","light2","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setFog","setLights","enableLighting","enable","setMaterial","setColor","drawMeshArray","meshes","modelViewMartrix","model","mesh","normalMatrix","computeNormalMatrix","normals","multiplyHomArr","transformedNormals","transformedPoints","faces","normal1","n1","normal2","n2","normal3","n3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","vertex","sub","mul","subject","input","S","point","push","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","normalize","max","dot","v","pow","Light","PointLight","Material","emissiveColor"],"sourceRoot":""}