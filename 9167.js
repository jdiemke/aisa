"use strict";(self.webpackChunkaisa=self.webpackChunkaisa||[]).push([[9167],{9167:(t,e,o)=>{o.r(e),o.d(e,{Scene13:()=>g});var r=o(7574),i=o(7552),s=o(9941);class n extends s.l{constructor(t=!1){super();const e=[];for(let t=0;t<80;t++){const o=this.torusFunction3(2*t*Math.PI/80),r=this.torusFunction3(2*t*Math.PI/80+.1),i=r.sub(o);let s=o.add(r).normalize();const n=i.cross(s).normalize().mul(26.4);s=n.cross(i).normalize().mul(26.4);for(let t=0;t<8;t++){const r=s.mul(Math.sin(2*t*Math.PI/8)).add(n.mul(Math.cos(2*t*Math.PI/8))).add(o);e.push(r.mul(1))}}const o=[];for(let t=0;t<80;t++)for(let r=0;r<8;r++)o.push((8*t+(1+r)%8)%e.length),o.push((8*t+(0+r)%8)%e.length),o.push((8*t+8+(1+r)%8)%e.length),o.push((8*t+8+(0+r)%8)%e.length),o.push((8*t+8+(1+r)%8)%e.length),o.push((8*t+(0+r)%8)%e.length);this.buildMesh(e,o,t)}torusFunction3(t){const e=.5*(2+Math.sin(3*t));return new i.l(e*Math.cos(2*t),e*Math.cos(3*t),e*Math.sin(2*t)).mul(70)}}var l=o(7401),a=o(9999);class h{}class c extends h{zStart;zEnd;fogColor;constructor(t,e,o){super(),this.zStart=t,this.zEnd=e,this.fogColor=o}computeVertexColor(t,e){if(e.z>=this.zStart)return t;if(e.z<=this.zEnd)return this.fogColor;{const o=(this.zEnd-e.z)/(this.zEnd-this.zStart);return new i.l(t.x*o+this.fogColor.x*(1-o),t.y*o+this.fogColor.y*(1-o),t.z*o+this.fogColor.z*(1-o))}}}var p=o(8931),u=o(82),f=o(9293),d=o(1762);class m extends a.p{noise;particleTexture;cocoon;torusKnot=new n(!0);fog=new c(-50,-240,new i.l(.67,.4,.5,1));renderingPipeline;init(t){return this.renderingPipeline=new d.M(t),this.renderingPipeline.setCullFace(r.u.FRONT),this.renderingPipeline.setFog(this.fog),Promise.all([u.O.generateProceduralNoise().then((t=>this.noise=t)),u.O.load(o(9328),!1).then((t=>this.cocoon=t)),u.O.generateProceduralParticleTexture2().then((t=>this.particleTexture=t))])}render(t,e){this.renderingPipeline.setCullFace(r.u.FRONT),this.torusTunnel(t,.019*e),t.drawScaledTextureClipAdd(t.width/2-this.cocoon.width/2,t.height/2-this.cocoon.height/2,this.cocoon.width,this.cocoon.height,this.cocoon,.67),this.glitchScreen(t,5*e,this.noise)}glitchScreen(t,e,o,r=!0){const i=.9*Math.sin(2e-5*e)+.1,s=new f.Z;s.setSeed(e/250|0);const n=new p.x;n.height=t.height,n.width=t.width,n.texture=t.framebuffer;const l=20,a=Math.floor(t.width/l),h=Math.floor(t.height/l);for(let e=0;e<a;e++)for(let o=0;o<h;o++)s.getFloat()>.25||t.drawTextureRect(l*(a-e),l*(a*s.getFloat()|0),l*e,l*o,l,l,n.texture,n.width,.03+.35*i);if(r)for(let r=0;r<a;r++)for(let s=0;s<h;s++)t.drawTextureRect(r*l,s*l,l*(Math.round(e/100+r+s)%12),0,l,l,o.texture,o.width,.1+.3*i);t.fastFramebufferCopy(t.tmpGlitch,t.framebuffer);const c=new f.Z;for(let o=0;o<8;o++){let o=Math.round(180*s.getFloat());const r=3+Math.round(20*s.getFloat());c.setSeed(e/250|0);const n=c.getFloat()*i,l=s.getFloat()*i;for(let i=0;i<r;i++){const r=Math.abs(Math.round(25*l)+Math.round(3*c.getFloat())+Math.round(Math.cos(.01*i+.002*e+l)*n*5));let s=o*t.width,a=o*t.width+t.width-r;for(let e=0;e<Math.max(0,r);e++)t.framebuffer[s++]=t.tmpGlitch[a++];a=o*t.width;const h=t.width-r;for(let e=0;e<h;e++)t.framebuffer[s++]=t.tmpGlitch[a++];o++}}}torusTunnel(t,e){t.clearDepthBuffer();const o=this.torusFunction3(.02*e),r=this.torusFunction3(.02*e+.4),i=r.sub(o).normalize();let s=o.add(r).normalize();const n=i.cross(s).normalize();s=n.cross(i).normalize();const a=l.C.constructIdentityMatrix();a.m14=-o.x,a.m24=-o.y,a.m34=-o.z;const h=l.C.constructIdentityMatrix();h.m11=n.x,h.m21=n.y,h.m31=n.z,h.m12=s.x,h.m22=s.y,h.m32=s.z,h.m13=-i.x,h.m23=-i.y,h.m33=-i.z;const c=h.transpose().multiplyMatrix(a);let p=l.C.constructScaleMatrix(1,1,1).multiplyMatrix(l.C.constructYRotationMatrix(.035*e));p=l.C.constructTranslationMatrix(0,0,-10).multiplyMatrix(p.multiplyMatrix(l.C.constructXRotationMatrix(.04*e))),p=l.C.constructZRotationMatrix(.01*e).multiplyMatrix(c),this.renderingPipeline.draw(t,this.torusKnot.getMesh(),p)}torusFunction3(t){const e=.5*(2+Math.sin(3*t));return new i.l(e*Math.cos(2*t),e*Math.cos(3*t),e*Math.sin(2*t)).mul(70)}}class g{TorusKnotTunnelScene;init(t){return this.TorusKnotTunnelScene=new m,Promise.all([this.TorusKnotTunnelScene.init(t)])}render(t,e){this.TorusKnotTunnelScene.render(t,e)}}},312:(t,e,o)=>{o.d(e,{u:()=>i});var r=o(1829);class i{startColor=new r.I;colorSlope=new r.I;setup(t,e,o){this.colorSlope.r=(e.r-t.r)/o,this.colorSlope.g=(e.g-t.g)/o,this.colorSlope.b=(e.b-t.b)/o,this.startColor.r=t.r,this.startColor.g=t.g,this.startColor.b=t.b}advance(){this.startColor.r+=this.colorSlope.r,this.startColor.g+=this.colorSlope.g,this.startColor.b+=this.colorSlope.b}}},5110:(t,e,o)=>{o.d(e,{_:()=>n});var r=o(3242),i=o(312),s=o(1417);class n extends r.Y{framebuffer;colorInterpolator1=new i.u;colorInterpolator2=new i.u;colorInterpolator3=new i.u;rowColorInterpolator=new i.u;leftSlope=new s.N;rightSlope=new s.N;constructor(t){super(),this.framebuffer=t}fillLongRightTriangle(t,e,o,r){this.leftSlope.setup(e,o),this.rightSlope.setup(e,r),this.colorInterpolator1.setup(e.color,o.color,this.leftSlope.yDistance),this.colorInterpolator2.setup(e.color,r.color,this.rightSlope.yDistance),this.drawSpan(t,this.leftSlope,this.colorInterpolator1,this.colorInterpolator2,this.leftSlope,this.rightSlope),this.leftSlope.setup(o,r),this.colorInterpolator3.setup(o.color,r.color,this.leftSlope.yDistance),this.drawSpan(t,this.leftSlope,this.colorInterpolator3,this.colorInterpolator2,this.leftSlope,this.rightSlope)}fillLongLeftTriangle(t,e,o,r){this.leftSlope.setup(e,r),this.rightSlope.setup(e,o),this.colorInterpolator2.setup(e.color,o.color,this.rightSlope.yDistance),this.colorInterpolator1.setup(e.color,r.color,this.leftSlope.yDistance),this.drawSpan(t,this.rightSlope,this.colorInterpolator1,this.colorInterpolator2,this.leftSlope,this.rightSlope),this.rightSlope.setup(o,r),this.colorInterpolator3.setup(o.color,r.color,this.rightSlope.yDistance),this.drawSpan(t,this.rightSlope,this.colorInterpolator1,this.colorInterpolator3,this.leftSlope,this.rightSlope)}drawSpan(t,e,o,r,i,s){let n=e.yStart;for(let l=0;l<e.yDistance;l++){const e=Math.round(s.currentX)-Math.round(i.currentX);this.rowColorInterpolator.setup(o.startColor,r.startColor,e);let l=Math.round(n)*t.width+Math.round(i.currentX);const a=(s.currentZ-i.currentZ)/e;let h=i.currentZ;for(let o=0;o<e;o++)h<t.wBuffer[l]&&(t.wBuffer[l]=h,t.framebuffer[l]=this.rowColorInterpolator.startColor.toPackedFormat()),l++,h+=a,this.rowColorInterpolator.advance();i.advance(),s.advance(),o.advance(),r.advance(),n++}}}},1417:(t,e,o)=>{o.d(e,{N:()=>r});class r{yDistance;slope;zslope;currentZ;currentX;yStart;setup(t,e){this.yDistance=e.projection.y-t.projection.y,this.slope=(e.projection.x-t.projection.x)/this.yDistance,this.zslope=(1/e.projection.z-1/t.projection.z)/this.yDistance,this.currentZ=1/t.projection.z,this.currentX=t.projection.x,this.yStart=t.projection.y}advance(){this.currentX+=this.slope,this.currentZ+=this.zslope}}},1762:(t,e,o)=>{o.d(e,{M:()=>u});var r=o(1829),i=o(7552),s=o(160),n=o(9166),l=o(5084),a=o(5335),h=o(7569),c=o(5787),p=o(5110);class u extends c.U{fog=null;lights=null;material=null;lighting=!0;color=r.I.WHITE;triangleRasterizer=null;clipper;projectedVertices=new Array(new i.l(0,0,0,1),new i.l(0,0,0,1),new i.l(0,0,0,1));vertexArray=new Array(new h.X,new h.X,new h.X);constructor(t){super(t),this.clipper=new s.m(t);const e=new l.c;e.ambientIntensity=new i.l(1,1,1,1),e.diffuseIntensity=new i.l(1,1,1,1),e.specularIntensity=new i.l(1,1,1,1),e.position=new i.l(3,0,-2,1);const o=new l.c;o.ambientIntensity=new i.l(0,0,1,1),o.diffuseIntensity=new i.l(0,.6,1,1),o.specularIntensity=new i.l(.8,.8,.8,1),o.position=new i.l(0,-380,-180,1),this.lights=[e,o];const r=new a.F;r.ambientColor=new i.l(.12,.14,.1,0),r.diffuseColor=new i.l(.38,.4,.4,1),r.specularColor=new i.l(.8,.5,.5,0),r.shininess=2,this.material=r,this.triangleRasterizer=new p._(t)}setFramebuffer(t){this.framebuffer=t}setFog(t){this.fog=t}setLights(t){this.lights=t}enableLighting(t){this.lighting=t}setMaterial(t){this.material=t}setColor(t){this.color=t}drawMeshArray(t,e,o){for(let r=0;r<e.length;r++){const i=e[r];this.draw(t,i,o)}}draw(t,e,o){const r=o.computeNormalMatrix();for(let t=0;t<e.normals.length;t++)r.multiplyHomArr(e.normals[t],e.transformedNormals[t]);for(let t=0;t<e.points.length;t++)o.multiplyHomArr(e.points[t],e.transformedPoints[t]);for(let o=0;o<e.faces.length;o++){const r=e.transformedPoints[e.faces[o].v1],i=e.transformedPoints[e.faces[o].v2],s=e.transformedPoints[e.faces[o].v3],n=e.transformedNormals[e.faces[o].n1],l=e.transformedNormals[e.faces[o].n2],a=e.transformedNormals[e.faces[o].n3];if(this.isInFrontOfNearPlane(r)&&this.isInFrontOfNearPlane(i)&&this.isInFrontOfNearPlane(s))this.project2(r,this.projectedVertices[0]),this.project2(i,this.projectedVertices[1]),this.project2(s,this.projectedVertices[2]),this.vertexArray[0].position=r,this.vertexArray[0].projection=this.projectedVertices[0],this.vertexArray[0].normal=n,this.vertexArray[1].position=i,this.vertexArray[1].projection=this.projectedVertices[1],this.vertexArray[1].normal=l,this.vertexArray[2].position=s,this.vertexArray[2].projection=this.projectedVertices[2],this.vertexArray[2].normal=a,this.renderConvexPolygon(t,this.vertexArray,!0);else{if(!(this.isInFrontOfNearPlane(r)||this.isInFrontOfNearPlane(i)||this.isInFrontOfNearPlane(s)))continue;{this.vertexArray[0].position=r,this.vertexArray[1].position=i,this.vertexArray[2].position=s,this.lighting?(this.vertexArray[0].color=this.computeColor(n,r),this.vertexArray[1].color=this.computeColor(l,i),this.vertexArray[2].color=this.computeColor(a,s)):(this.vertexArray[0].color=this.color,this.vertexArray[1].color=this.color,this.vertexArray[2].color=this.color);const e=this.zClipTriangle(this.vertexArray);if(e.length<3)return;for(let t=0;t<e.length;t++)e[t].projection=this.project(e[t].position);this.renderConvexPolygon(t,e,!1)}}}}project(t){return new i.l(Math.round(this.framebuffer.width/2+292*t.x/-t.z),Math.round(this.framebuffer.height/2-292*t.y/-t.z),t.z)}project2(t,e){e.x=Math.round(this.framebuffer.width/2+292*t.x/-t.z),e.y=Math.round(this.framebuffer.height/2-292*t.y/-t.z),e.z=t.z}computeNearPlaneIntersection(t,e){const o=(this.NEAR_PLANE_Z-t.position.z)/(e.position.z-t.position.z),r=new h.X;return r.position=new i.l(o*(e.position.x-t.position.x)+t.position.x,o*(e.position.y-t.position.y)+t.position.y,this.NEAR_PLANE_Z),r.color=e.color.sub(t.color).mul(o).add(t.color),r}zClipTriangle(t){const e=t,o=new Array;let r=e[e.length-1];for(let t=0;t<e.length;t++){const i=e[t];this.isInFrontOfNearPlane(i.position)?(this.isInFrontOfNearPlane(r.position)||o.push(this.computeNearPlaneIntersection(r,i)),o.push(i)):this.isInFrontOfNearPlane(r.position)&&o.push(this.computeNearPlaneIntersection(r,i)),r=i}return o}renderConvexPolygon(t,e,o=!1){if(3===e.length&&!this.isTriangleCCW(e[0].projection,e[1].projection,e[2].projection))return;if(o&&(this.lighting?(this.vertexArray[0].color=this.computeColor(this.vertexArray[0].normal,this.vertexArray[0].position),this.vertexArray[1].color=this.computeColor(this.vertexArray[1].normal,this.vertexArray[1].position),this.vertexArray[2].color=this.computeColor(this.vertexArray[2].normal,this.vertexArray[2].position)):(this.vertexArray[0].color=this.color,this.vertexArray[1].color=this.color,this.vertexArray[2].color=this.color)),4===e.length&&!this.isTriangleCCW2(e[0].projection,e[1].projection,e[2].projection,e[3].projection))return;const r=this.clipper.clipConvexPolygon(e);r.length<3||this.triangulateConvexPolygon(t,r)}triangulateConvexPolygon(t,e){for(let o=0;o<e.length-2;o++)this.triangleRasterizer.drawTriangleDDA(t,e[0],e[1+o],e[2+o])}computeColor(t,e){let o=(new n.R).computeColor(this.material,this.lights,t,e);return null!==this.fog&&(o=this.fog.computeVertexColor(o,e)),new r.I(Math.min(255,255*o.x),Math.min(255,255*o.y),Math.min(255,255*o.z),255)}}},160:(t,e,o)=>{o.d(e,{m:()=>l});var r=o(9137),i=o(477),s=o(6076),n=o(9936);class l{framebuffer;clipRegion;constructor(t){this.framebuffer=t,this.clipRegion=new Array(new r.N(t),new i.c(t),new s.$(t),new n.E(t))}clipConvexPolygon(t){let e=t;for(let t=0;t<this.clipRegion.length;t++){const o=this.clipRegion[t],r=e;e=new Array;let i=r[r.length-1];for(let t=0;t<r.length;t++){const s=r[t];o.isInside(s)?(o.isInside(i)||e.push(o.computeIntersection(i,s)),e.push(s)):o.isInside(i)&&e.push(o.computeIntersection(i,s)),i=s}}return e}}},9166:(t,e,o)=>{o.d(e,{R:()=>i});var r=o(7552);class i{computeColor(t,e,o,i){let s=new r.l(0,0,0);for(let r=0;r<e.length;r++){const n=e[r],l=this.computeAmbientIntensity(t,n),a=this.computeDiffuseIntensity(t,n,o,i),h=this.computeSpecularIntensity(t,n,o,i);s=s.add(l).add(a).add(h)}return s}computeAmbientIntensity(t,e){return t.ambientColor.componentWiseMul(e.ambientIntensity)}computeDiffuseIntensity(t,e,o,r){const i=e.position.sub(r).normalize(),s=Math.min(Math.max(o.dot(i),0),1);return t.diffuseColor.componentWiseMul(e.diffuseIntensity).mul(s)}computeSpecularIntensity(t,e,o,r){const i=e.position.sub(r).normalize(),s=o.mul(2*o.dot(i)).sub(i),n=r.mul(-1).normalize(),l=Math.pow(Math.max(s.dot(n),0),t.shininess);return t.specularColor.componentWiseMul(e.specularIntensity).mul(l)}}},9866:(t,e,o)=>{o.d(e,{_:()=>r});class r{ambientIntensity;diffuseIntensity;specularIntensity}},5084:(t,e,o)=>{o.d(e,{c:()=>i});var r=o(9866);class i extends r._{position}},5335:(t,e,o)=>{o.d(e,{F:()=>r});class r{ambientColor;diffuseColor;specularColor;emissiveColor;shininess}},9328:(t,e,o)=>{t.exports=o.p+"7fe555ee73184c72e031.png"}}]);
//# sourceMappingURL=9167.js.map