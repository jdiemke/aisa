{"version":3,"file":"2193.js","mappings":"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","sources":["webpack://aisa/./src/examples/demo/parts/Scene1.ts","webpack://aisa/./src/examples/plane-deformation/PlaneDeformationScene.ts"],"sourcesContent":["import { Framebuffer } from '../../../Framebuffer';\nimport { PlaneDeformationScene } from '../../plane-deformation/PlaneDeformationScene';\n\n// sideways 3D office scene\nexport class Scene1 {\n    private PlaneDeformationFloorScene: PlaneDeformationScene;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.PlaneDeformationFloorScene = new PlaneDeformationScene(8, require('@assets/ground.png'));\n\n        return Promise.all([\n            this.PlaneDeformationFloorScene.init(framebuffer)\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.PlaneDeformationFloorScene.drawPlaneDeformation(framebuffer, 0, time >> 3);\n    }\n\n}\n","import { Framebuffer } from '../../Framebuffer';\nimport { Texture, TextureUtils } from '../../texture';\nimport { Color } from '../../core/Color';\nimport { Utils } from '../../core/Utils';\n\n/**\n * Plane deformation\n *\n * 2D plane deformations using lookup tables was a great\n * way to get smooth animations of complex calculations\n * running on slower processors. These effects were very\n * common in the 90s demoscene.\n *\n * The idea was to take a texture and deform it using a\n * pre-calculated math reference table. Different formulas\n * gave different effects such as fake 3d tunnels, wormholes\n * and landscapes.\n *\n * https://www.iquilezles.org/www/articles/deform/deform.htm\n *\n */\n\nexport class PlaneDeformationScene {\n\n    private mLUT: Int32Array;\n    public texture: Texture;\n\n    constructor(\n        private effectStyle: number,\n        private texturePath: string\n    ) {\n    }\n\n    onInit() { }\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        return Promise.all([\n            TextureUtils.load(this.texturePath, false).then(\n                (texture: Texture) => {\n                    this.texture = texture;\n                    this.createLUT(this.effectStyle, framebuffer.width, framebuffer.height, this.texture.width, this.texture.height);\n                }\n            ),\n        ]);\n\n    }\n\n    // fill math lookup table values with crazy values\n    public createLUT(effectStyle: number, effectWidth: number, effectHeight: number, textureWidth: number, textureHeight: number): Promise<any> {\n\n        // initializae lookup array\n        this.mLUT = new Int32Array(3 * effectWidth * effectHeight);\n\n        // increment placeholder\n        let k = 0;\n\n        // u and v are euclidean coordinates\n        let u = 0;\n        let v = 0\n        let bright = 0;\n\n        for (let j = 0; j < effectHeight; j++) {\n            const y = -1.00 + 2.00 * j / effectHeight;\n            for (let i = 0; i < effectWidth; i++) {\n                const x = -1.00 + 2.00 * i / effectWidth;\n                const d = Math.sqrt(x * x + y * y);\n                const a = Math.atan2(y, x);\n\n                const r = d;\n                switch (effectStyle) {\n                    case 1:   // stereographic projection / anamorphosis\n                        u = Math.cos(a) / d;\n                        v = Math.sin(a) / d;\n                        bright = -50 * (2 / (6 * r + 3 * x));\n                        break;\n                    case 2:  // hypnotic rainbow spiral\n                        v = Math.sin(a + Math.cos(3 * r)) / (Math.pow(r, .2));\n                        u = Math.cos(a + Math.cos(3 * r)) / (Math.pow(r, .2));\n                        bright = 1;\n                        break;\n                    case 3:  // rotating tunnel\n                        v = 2 / (6 * r + 3 * x);\n                        u = a * 3 / Math.PI;\n                        bright = 25 * -v;\n                        break;\n                    case 4:  // wavy star-burst\n                        v = (-0.4 / r) + .1 * Math.sin(8 * a);\n                        u = .5 + .5 * a / Math.PI;\n                        bright = 0;\n                        break;\n                    case 5:  // hyper-space travel\n                        u = (0.02 * y + 0.03) * Math.cos(a * 3) / r;\n                        v = (0.02 * y + 0.03) * Math.sin(a * 3) / r;\n                        bright = 0;\n                        break;\n                    case 6:  // five point magnetic flare\n                        u = 1 / (r + 0.5 + 0.5 * Math.sin(5 * a));\n                        v = a * 3 / Math.PI;\n                        bright = 0;\n                        break;\n                    case 7:  // cloud like dream scroll\n                        u = 0.1 * x / (0.11 + r * 0.5);\n                        v = 0.1 * y / (0.11 + r * 0.5);\n                        bright = 0;\n                        break;\n                    case 8:  // floor and ceiling with fade to dark horizon\n                        u = x / Math.abs(y);\n                        v = 1 / Math.abs(y);\n                        bright = 40 * -v;\n                        break;\n                    case 9:  // hot magma liquid swirl\n                        u = 0.5 * (a) / Math.PI;\n                        v = Math.sin(2 * r);\n                        bright = 0;\n                        break;\n                    case 10:  // clockwise flush down the toilet\n                        v = Math.pow(r, 0.1);\n                        u = (1 * a / Math.PI) + r;\n                        bright = 0;\n                        break;\n                    case 11:  // 3D ball\n                        v = x * (3 - Math.sqrt(4 - 5 * r * r)) / (r * r + 1);\n                        u = y * (3 - Math.sqrt(4 - 5 * r * r)) / (r * r + 1);\n                        bright = 7 * -18.7 * (x + y + r * r - (x + y - 1) * Math.sqrt(4 - 5 * r * r) / 3) / (r * r + 1);\n                        break;\n                    default:  // show texture with no deformation or lighting\n                        u = x;\n                        v = y;\n                        bright = 0;\n                        break;\n                }\n                this.mLUT[k++] = (textureWidth * u) & textureWidth - 1;\n                this.mLUT[k++] = (textureHeight * v) & textureHeight - 1;\n                this.mLUT[k++] = Utils.clamp(bright, -255, 255);\n            }\n        }\n        return Promise.all([]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        // this.drawOldPlaneDeformationStar(framebuffer, time >> 3);\n        // this.drawOldPlaneDeformationFloor(framebuffer, time >> 3);\n        this.drawPlaneDeformation(framebuffer, time >> 3, time >> 3);\n    }\n\n    /**\n     * For every frame, go through every pixel and use the reference table (mLUT)\n     * to get which pixel of the texture it should draw at the current pixel.\n     *\n     * TODO:\n     * - Rotate effect via rotozoomer class\n     *   use drawOldPlaneDeformationStar to add another lookup layer [mLUT * 4]\n     *   use drawOldPlaneDeformationFloor to update createLUT(8) floor algorithm\n     *\n     */\n    drawPlaneDeformation(framebuffer: Framebuffer, elapsedTimeY: number, elapsedTimeX: number) {\n\n        for (let pixelCount = 0; pixelCount < framebuffer.framebuffer.length; pixelCount++) {\n            const o = (pixelCount << 1) + pixelCount; // equivalent to 3 * pixelCount\n            const u = this.mLUT[o + 0] + elapsedTimeX; // to look like its animating, add timeDisplacement\n            const v = this.mLUT[o + 1] + elapsedTimeY;\n            const adjustBrightness = this.mLUT[o + 2]; // fade out\n\n            // get the R,G,B values from texture\n            let currentPixel = this.texture.texture[this.texture.width * (v & this.texture.height - 1) + (u & this.texture.width - 1)];\n\n            // only apply brightness if it was calculated\n            if (adjustBrightness !== 0) {\n\n                // disassemble pixel using bit mask to remove color components for greater speed\n                let r = currentPixel & 0xFF;        // get red\n                let g = currentPixel >> 8 & 0xFF;   // get green\n                let b = currentPixel >> 16 & 0xFF;  // get blue\n\n                // make darker or brighter\n                r += adjustBrightness;\n                g += adjustBrightness;\n                b += adjustBrightness;\n\n                // constrain RGB to make sure they are within 0-255 color range\n                r = Utils.clamp(r, 0, 255);\n                g = Utils.clamp(g, 0, 255);\n                b = Utils.clamp(b, 0, 255);\n\n                // reassemble colors back into pixel\n                currentPixel = new Color(r, g, b, 255).toPackedFormat();\n            }\n\n            // put texture pixel on buffer screen\n            framebuffer.framebuffer[pixelCount] = currentPixel;\n        }\n    }\n\n    /**\n     *\n     * Previous Plane deformation without lookup tables for reference\n     *\n     * http://sol.gfxile.net/gp/ch17.html\n     * TODO:\n     * - better textures\n     * - precalc lookup tables\n     * - fadeout\n     * - substraction to create black holes\n     */\n    drawOldPlaneDeformationFloor(framebuffer: Framebuffer, elapsedTime: number) {\n        /*\n        mLUT(8)\n            u = x / Math.abs(y);\n            v = 1 / Math.abs(y);\n            bright = 10 * -v;\n        */\n        let i = 0;\n        for (let y = 0; y < framebuffer.height; y++) {\n            const ydist = (y - framebuffer.height / 2);\n            const v = (((1 / Math.abs(ydist / 100 * 0.02) + elapsedTime * 0.069) % 256) + 256) % 256;\n            const alpha = 1 - Math.min(1, (1 / Math.abs(ydist / 10)));\n            for (let x = 0; x < framebuffer.width; x++) {\n                const xdist = (x - (framebuffer.width / 2));\n                const u = (((((xdist / framebuffer.width) / Math.abs(ydist / 100 * 0.02))) % 256) + 256) % 256;\n                const color1 = this.texture.texture[(u | 0) + (v | 0) * 256];\n                const r = (((color1 >> 0) & 0xff) * (alpha)) | 0;\n                const g = (((color1 >> 8) & 0xff) * (alpha)) | 0;\n                const b = (((color1 >> 16) & 0xff) * (alpha)) | 0;\n                framebuffer.framebuffer[i++] = r | g << 8 | b << 16 | 255 << 24;\n            }\n        }\n    }\n\n    drawOldPlaneDeformationStar(framebuffer: Framebuffer, elapsedTime: number) {\n        let i = 0;\n        for (let y = 0; y < framebuffer.height; y++) {\n            for (let x = 0; x < framebuffer.width; x++) {\n                const xdist = (x - (framebuffer.width / 2)) / (framebuffer.width / 2);\n                const ydist = (y - framebuffer.height / 2) / (framebuffer.height / 2);\n                const alpha = 1;// 1 - Math.min(1, (1 / Math.abs(ydist / 10)));\n                const a = Math.atan2(ydist, xdist) + elapsedTime * 0.0004;\n                const v = (a * 3 / Math.PI + elapsedTime * 0.0004) * 128 % 256;\n                const d = Math.sqrt(xdist * xdist + ydist * ydist);\n                const u = (1 / (d + 0.5 + 0.5 * Math.sin(5 * a)) * 32 + elapsedTime * 0.03) % 256;\n                const color1 = this.texture.texture[(u | 0) + (v | 0) * 256];\n                const r = (((color1 >> 0) & 0xff) * (alpha)) | 0;\n                const g = (((color1 >> 8) & 0xff) * (alpha)) | 0;\n                const b = (((color1 >> 16) & 0xff) * (alpha)) | 0;\n                framebuffer.framebuffer[i++] = r | g << 8 | b << 16 | 255 << 24;\n            }\n        }\n    }\n\n}\n"],"names":["Scene1","PlaneDeformationFloorScene","init","framebuffer","this","Promise","all","render","time","drawPlaneDeformation","PlaneDeformationScene","effectStyle","texturePath","mLUT","texture","constructor","onInit","load","then","createLUT","width","height","effectWidth","effectHeight","textureWidth","textureHeight","Int32Array","k","u","v","bright","j","y","i","x","d","Math","sqrt","a","atan2","r","cos","sin","pow","PI","abs","clamp","elapsedTimeY","elapsedTimeX","pixelCount","length","o","adjustBrightness","currentPixel","g","b","toPackedFormat","drawOldPlaneDeformationFloor","elapsedTime","ydist","alpha","min","color1","drawOldPlaneDeformationStar","xdist"],"sourceRoot":""}