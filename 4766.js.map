{"version":3,"file":"4766.js","mappings":"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","sources":["webpack://aisa/./src/examples/torus-knot-tunnel/TorusKnotTunnelScene.ts","webpack://aisa/./src/geometrical-objects/TorusKnot.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/fog/Fog.ts","webpack://aisa/./src/shading/fog/LinearFog.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { TorusKnot } from '../../geometrical-objects/TorusKnot';\nimport { Matrix4f } from '../../math/Matrix4f';\nimport { Vector4f } from '../../math/Vector4f';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Fog } from '../../shading/fog/Fog';\nimport { LinearFog } from '../../shading/fog/LinearFog';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\nimport RandomNumberGenerator from '../../RandomNumberGenerator';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\n\nexport class TorusKnotTunnelScene extends AbstractScene {\n\n    private noise: Texture;\n    private particleTexture: Texture;\n    private cocoon: Texture;\n    private torusKnot: TorusKnot = new TorusKnot(true);\n    private fog: Fog = new LinearFog(-50, -240, new Vector4f(0.67, 0.4, 0.5, 1.0));\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.renderingPipeline.setCullFace(CullFace.FRONT);\n        this.renderingPipeline.setFog(this.fog);\n\n        return Promise.all([\n            TextureUtils.generateProceduralNoise().then((texture: Texture) => this.noise = texture),\n            TextureUtils.load(require('../../assets/cocoon.png'), false).then(\n                (texture: Texture) => this.cocoon = texture\n            ),\n            TextureUtils.generateProceduralParticleTexture2().then(\n                (texture: Texture) => this.particleTexture = texture\n            ),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.renderingPipeline.setCullFace(CullFace.FRONT);\n        this.torusTunnel(framebuffer, time * 0.019);\n        framebuffer.drawScaledTextureClipAdd(\n            framebuffer.width / 2 - this.cocoon.width / 2,\n            framebuffer.height / 2 - this.cocoon.height / 2,\n            this.cocoon.width, this.cocoon.height, this.cocoon, 0.67);\n\n        // framebuffer.noise(time, this.noise);\n        this.glitchScreen(framebuffer, time * 5, this.noise);\n    }\n\n    public glitchScreen(framebuffer: Framebuffer, elapsedTime: number, texture: Texture, noise: boolean = true): void {\n\n        const glitchFactor = (Math.sin(elapsedTime * 0.00002) * 0.9 + 0.1);\n        const rng = new RandomNumberGenerator();\n        rng.setSeed((elapsedTime / 250) | 0);\n        const texture2 = new Texture();\n        texture2.height = framebuffer.height;\n        texture2.width = framebuffer.width;\n        texture2.texture = framebuffer.framebuffer;\n\n\n        const blockWidth = 20;\n        const horizontalUnits = Math.floor(framebuffer.width / blockWidth);\n        const verticalUnits = Math.floor(framebuffer.height / blockWidth);\n\n        for (let x = 0; x < horizontalUnits; x++) {\n            for (let y = 0; y < verticalUnits; y++) {\n                if (rng.getFloat() > 0.25) {\n                    continue;\n                }\n\n                framebuffer.drawTextureRect(blockWidth * (horizontalUnits - x), blockWidth * ((horizontalUnits * rng.getFloat()) | 0), blockWidth * x, blockWidth * y, blockWidth, blockWidth, texture2.texture, texture2.width, 0.03 + 0.35 * glitchFactor);\n            }\n        }\n\n        if (noise) {\n            for (let x = 0; x < horizontalUnits; x++) {\n                for (let y = 0; y < verticalUnits; y++) {\n                    framebuffer.drawTextureRect(x * blockWidth, y * blockWidth, blockWidth * (Math.round(elapsedTime / 100 + x + y) % 12), 0, blockWidth, blockWidth, texture.texture, texture.width, 0.1 + 0.3 * glitchFactor);\n                }\n            }\n        }\n\n        framebuffer.fastFramebufferCopy(framebuffer.tmpGlitch, framebuffer.framebuffer);\n\n        // now distort the tmpGlitch buffer and render to framebuffer again\n\n        const rng2 = new RandomNumberGenerator();\n\n        for (let k = 0; k < 8; k++) {\n            let yStart = Math.round(rng.getFloat() * 180);\n            const size = 3 + Math.round(rng.getFloat() * 20);\n            rng2.setSeed((elapsedTime / 250) | 0);\n            const scale = rng2.getFloat() * glitchFactor;\n            const off = rng.getFloat() * glitchFactor;\n            for (let y = 0; y < size; y++) {\n                const offset = Math.abs(Math.round(off * 25) + Math.round(rng2.getFloat() * 3)\n                    + Math.round(Math.cos(y * 0.01 + elapsedTime * 0.002 + off) * scale * 5));\n\n                let index = yStart * framebuffer.width;\n                let glIndex = yStart * framebuffer.width + framebuffer.width - offset;\n\n                for (let i = 0; i < Math.max(0, offset); i++) {\n                    framebuffer.framebuffer[index++] = framebuffer.tmpGlitch[glIndex++];\n                }\n\n                glIndex = yStart * framebuffer.width;\n                const count = framebuffer.width - offset;\n\n                for (let i = 0; i < count; i++) {\n                    framebuffer.framebuffer[index++] = framebuffer.tmpGlitch[glIndex++];\n                }\n                yStart++;\n            }\n        }\n    }\n\n    public torusTunnel(framebuffer: Framebuffer, elapsedTime: number): void {\n        framebuffer.clearDepthBuffer();\n\n        const scale = 1.0;\n        const lookAhead: number = 0.4;\n\n        const frame = this.torusFunction3(elapsedTime * 0.02);\n        const frame2 = this.torusFunction3(elapsedTime * 0.02 + lookAhead);\n\n        const tangent = frame2.sub(frame).normalize();\n        let up = frame.add(frame2).normalize();\n        const right = tangent.cross(up).normalize();\n        up = right.cross(tangent).normalize();\n\n        const translation = Matrix4f.constructIdentityMatrix();\n        // translation vector\n        translation.m14 = -frame.x;\n        translation.m24 = -frame.y;\n        translation.m34 = -frame.z;\n\n        const rotation = Matrix4f.constructIdentityMatrix();\n        // x vector\n        rotation.m11 = right.x;\n        rotation.m21 = right.y;\n        rotation.m31 = right.z;\n\n        // y vector\n        rotation.m12 = up.x;\n        rotation.m22 = up.y;\n        rotation.m32 = up.z;\n\n        // z vector\n        rotation.m13 = -tangent.x;\n        rotation.m23 = -tangent.y;\n        rotation.m33 = -tangent.z;\n\n        const finalMatrix = rotation.transpose().multiplyMatrix(translation);\n\n        let modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale).multiplyMatrix(Matrix4f.constructYRotationMatrix(elapsedTime * 0.035));\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(0, 0, -10).multiplyMatrix(modelViewMartrix.multiplyMatrix(Matrix4f.constructXRotationMatrix(elapsedTime * 0.04)));\n        modelViewMartrix = Matrix4f.constructZRotationMatrix(elapsedTime * 0.01).multiplyMatrix(finalMatrix);\n\n        this.renderingPipeline.draw(framebuffer, this.torusKnot.getMesh(), modelViewMartrix);\n    }\n\n    private torusFunction3(alpha: number): Vector4f {\n        const p = 2;\n        const q = 3;\n        const r = 0.5 * (2 + Math.sin(q * alpha));\n        return new Vector4f(r * Math.cos(p * alpha),\n            r * Math.cos(q * alpha),\n            r * Math.sin(p * alpha)).mul(70);\n    }\n\n}\n","import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class TorusKnot extends AbstractGeometricObject {\n\n    public constructor(inverse: boolean = false) {\n        super();\n\n        const points: Array<Vector4f> = [];\n\n        const STEPS = 80;\n        const STEPS2 = 8;\n        for (let i = 0; i < STEPS; i++) {\n            const frame = this.torusFunction3(i * 2 * Math.PI / STEPS);\n            const frame2 = this.torusFunction3(i * 2 * Math.PI / STEPS + 0.1);\n\n            const tangent = frame2.sub(frame);\n            let up = frame.add(frame2).normalize();\n            const right = tangent.cross(up).normalize().mul(26.4);\n            up = right.cross(tangent).normalize().mul(26.4);\n\n            for (let r = 0; r < STEPS2; r++) {\n                const pos = up.mul(Math.sin(r * 2 * Math.PI / STEPS2)).add(right.mul(Math.cos(r * 2 * Math.PI / STEPS2))).add(frame);\n                points.push(pos.mul(1));\n            }\n        }\n\n        const index: Array<number> = [];\n\n\n\n        for (let j = 0; j < STEPS; j++) {\n            for (let i = 0; i < STEPS2; i++) {\n                index.push(((STEPS2 * j) + (1 + i) % STEPS2) % points.length); // 2\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2) % points.length); // 1\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2) % points.length); // 3\n\n                index.push(((STEPS2 * j) + STEPS2 + (0 + i) % STEPS2) % points.length); // 4\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2) % points.length); // 3\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2) % points.length); // 5\n            }\n        }\n\n        this.buildMesh(points, index, inverse);\n    }\n\n    private torusFunction3(alpha: number): Vector4f {\n        const p = 2\n        const q = 3;\n        const r = 0.5 * (2 + Math.sin(q * alpha));\n        return new Vector4f(r * Math.cos(p * alpha),\n            r * Math.cos(q * alpha),\n            r * Math.sin(p * alpha)).mul(70);\n    }\n\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Fog {\n\n    public abstract computeVertexColor(color: Vector4f, vertex: Vector4f): Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Fog } from './Fog';\n\nexport class LinearFog extends Fog {\n\n    private zStart: number;\n    private zEnd: number;\n    private fogColor: Vector4f;\n\n    public constructor(zStart: number, zEnd: number, fogColor: Vector4f) {\n        super();\n        this.zStart = zStart;\n        this.zEnd = zEnd;\n        this.fogColor = fogColor;\n    }\n\n    public computeVertexColor(color: Vector4f, vertex: Vector4f): Vector4f {\n        if (vertex.z >= this.zStart) {\n            return color;\n        } else if (vertex.z <= this.zEnd) {\n            return this.fogColor;\n        } else {\n            const f: number = (this.zEnd - vertex.z) / (this.zEnd - this.zStart);\n            return new Vector4f(\n                color.x * f + this.fogColor.x * (1 - f),\n                color.y * f + this.fogColor.y * (1 - f),\n                color.z * f + this.fogColor.z * (1 - f)\n            );\n        }\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["TorusKnotTunnelScene","noise","particleTexture","cocoon","torusKnot","fog","renderingPipeline","init","framebuffer","this","setCullFace","FRONT","setFog","Promise","all","generateProceduralNoise","then","texture","load","generateProceduralParticleTexture2","render","time","torusTunnel","drawScaledTextureClipAdd","width","height","glitchScreen","elapsedTime","glitchFactor","Math","sin","rng","setSeed","texture2","blockWidth","horizontalUnits","floor","verticalUnits","x","y","getFloat","drawTextureRect","round","fastFramebufferCopy","tmpGlitch","rng2","k","yStart","size","scale","off","offset","abs","cos","index","glIndex","i","max","count","clearDepthBuffer","frame","torusFunction3","frame2","tangent","sub","normalize","up","add","right","cross","translation","constructIdentityMatrix","m14","m24","m34","z","rotation","m11","m21","m31","m12","m22","m32","m13","m23","m33","finalMatrix","transpose","multiplyMatrix","modelViewMartrix","constructScaleMatrix","constructYRotationMatrix","constructTranslationMatrix","constructXRotationMatrix","constructZRotationMatrix","draw","getMesh","alpha","r","mul","TorusKnot","inverse","super","points","PI","pos","push","j","length","buildMesh","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","constructor","fillLongRightTriangle","v1","v2","v3","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","currentX","framebufferIndex","spanzStep","currentZ","wStart","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","GouraudShadingRenderingPipeline","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","Array","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","position","light2","mat","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setLights","enableLighting","enable","setMaterial","setColor","drawMeshArray","meshes","model","mesh","normalMatrix","computeNormalMatrix","normals","multiplyHomArr","transformedNormals","transformedPoints","faces","normal1","n1","normal2","n2","normal3","n3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","vertex","subject","input","S","point","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","Fog","LinearFog","zStart","zEnd","fogColor","f","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","dot","v","pow","Light","PointLight","Material","emissiveColor"],"sourceRoot":""}