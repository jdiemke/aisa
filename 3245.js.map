{"version":3,"file":"3245.js","mappings":"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","sources":["webpack://aisa/./src/geometrical-objects/Dodecahedron.ts","webpack://aisa/./src/geometrical-objects/Pyramid.ts","webpack://aisa/./src/geometrical-objects/Sphere.ts","webpack://aisa/./src/examples/razor/RazorScene.ts","webpack://aisa/./src/examples/demo/parts/Scene19.ts","webpack://aisa/./src/geometrical-objects/Cube.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts","webpack://aisa/./src/special-effects/LensFlare.ts"],"sourcesContent":["import { AbstractGeometricObject } from './AbstractGeometricObject';\nimport { Vector4f } from '../math/Vector4f';\n\nexport class Dodecahedron extends AbstractGeometricObject {\n\n    constructor() {\n\n        super();\n\n        // https://github.com/chiptune/lol3d/blob/master/index.html\n        const phi = (1 + Math.sqrt(5)) * 0.5;\n        const a = 1;\n        const b = 1 / phi;\n        const c = 2 - phi;\n\n        const points: Array<Vector4f> = [\n            new Vector4f(c, 0, a), new Vector4f(-c, 0, a), new Vector4f(-b, b, b), new Vector4f(0, a, c),\n            new Vector4f(b, b, b), new Vector4f(b, -b, b), new Vector4f(0, -a, c), new Vector4f(-b, -b, b),\n            new Vector4f(c, 0, -a), new Vector4f(-c, 0, -a), new Vector4f(-b, -b, -b), new Vector4f(0, -a, -c),\n            new Vector4f(b, -b, -b), new Vector4f(b, b, -b), new Vector4f(0, a, -c), new Vector4f(-b, b, -b),\n            new Vector4f(1, c, 0), new Vector4f(-a, c, 0), new Vector4f(-1, -c, 0), new Vector4f(a, -c, 0)\n        ];\n\n        const index: Array<number> = [\n            0, 4, 1, 1, 3, 2, 1, 4, 3, 1, 7, 0,\n            0, 6, 5, 0, 7, 6, 8, 12, 9, 9, 11, 10,\n            9, 12, 11, 9, 15, 8, 8, 14, 13, 8, 15, 14,\n            14, 3, 13, 13, 4, 16, 13, 3, 4, 3, 14, 2,\n            2, 15, 17, 2, 14, 15, 11, 6, 10, 10, 7, 18,\n            10, 6, 7, 6, 11, 5, 5, 12, 19, 5, 11, 12,\n            16, 4, 19, 19, 0, 5, 19, 4, 0, 19, 12, 16,\n            16, 8, 13, 16, 12, 8, 17, 15, 18, 18, 9, 10,\n            18, 15, 9, 18, 7, 17, 17, 1, 2, 17, 7, 1\n        ];\n\n        this.buildMesh(points, index);\n    }\n\n}\n","import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class Pyramid extends AbstractGeometricObject {\n\n    public constructor() {\n        super();\n        const a = 0.5;\n\n        const points: Array<Vector4f> = [\n            new Vector4f(0, a, 0),\n            new Vector4f(a, -a, -a),\n            new Vector4f(-a, -a, -a),\n            new Vector4f(a, -a, a),\n            new Vector4f(-a, -a, a)\n        ];\n\n        const index: Array<number> = [\n            0, 1, 2,\n            0, 3, 1,\n            0, 4, 3,\n            0, 2, 4\n        ];\n\n        this.buildMesh(points, index);\n    }\n\n}\n","import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class Sphere extends AbstractGeometricObject {\n\n    public constructor(xSteps: number = 16, ySteps: number = 16) {\n        super();\n\n        const points: Array<Vector4f> = [];\n\n        const STEPS = xSteps;\n        const STEPS2 = ySteps;\n        for (let i = 0; i <= STEPS; i++) {\n            for (let r = 0; r < STEPS2; r++) {\n                points.push(this.sphereFunction(-i * Math.PI / STEPS - Math.PI / 2, -r * 2 * Math.PI / STEPS2));\n            }\n        }\n\n        const index: Array<number> = [];\n\n        for (let j = 0; j < STEPS; j++) {\n            for (let i = 0; i < STEPS2; i++) {\n                index.push(((STEPS2 * j) + (1 + i) % STEPS2)); // 2\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2)); // 1\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2)); // 3\n\n                index.push(((STEPS2 * j) + STEPS2 + (0 + i) % STEPS2)); // 4\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2)); // 3\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2)); // 5\n            }\n        }\n\n        this.buildMesh(points, index);\n    }\n\n    private sphereFunction(theta: number, phi: number): Vector4f {\n        return new Vector4f(Math.cos(theta) * Math.cos(phi),\n            Math.cos(theta) * Math.sin(phi),\n            Math.sin(theta), 1.0);\n    }\n\n}\n","import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Cube } from '../../geometrical-objects/Cube';\nimport { Dodecahedron } from '../../geometrical-objects/Dodecahedron';\nimport { Pyramid } from '../../geometrical-objects/Pyramid';\nimport { Sphere } from '../../geometrical-objects/Sphere';\nimport { Matrix4f, Vector3f } from '../../math';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Texture, TextureUtils } from '../../texture';\nimport { Color } from '../../core/Color';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\nimport { LensFlare } from '../../special-effects/LensFlare';\n\n/**\n * TODO: extract lens into effect class\n */\nexport class RazorScene extends AbstractScene {\n\n    private texture10: Texture;\n    private texture11: Texture;\n    private texture13: Texture;\n    private dirt: Texture;\n    private noise: Texture;\n\n    private cube: Cube;\n    private dodecahedron: Dodecahedron;\n    private pyramid: Pyramid;\n    private icosahedron: Sphere; // Icosahedron;\n\n    private accumulationBuffer: Uint32Array;\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.accumulationBuffer = new Uint32Array(framebuffer.width * framebuffer.height);\n        this.renderingPipeline.setCullFace(CullFace.BACK);\n\n        this.cube = new Cube();\n        this.dodecahedron = new Dodecahedron();\n        this.pyramid = new Pyramid();\n        this.icosahedron = new Sphere(6, 10);\n\n        return Promise.all([\n            TextureUtils.load(require('./assets/spark.png'), true).then(texture => this.texture10 = texture),\n            TextureUtils.load(require('./assets/ring.png'), true).then(texture => this.texture11 = texture),\n            TextureUtils.load(require('./assets/bokeh.png'), true).then(texture => this.texture13 = texture),\n            TextureUtils.load(require('./assets/dirt.png'), true).then(texture => this.dirt = texture),\n            TextureUtils.generateProceduralNoise().then(texture => this.noise = texture),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n\n        this.reproduceRazorScene(framebuffer, time * 0.0025, [\n            { tex: this.texture10, scale: 0.0, alpha: 1.0 },\n            { tex: this.texture11, scale: 2.3, alpha: 0.5 },\n            { tex: this.texture13, scale: 1.6, alpha: 0.25 },\n            { tex: this.texture13, scale: 0.7, alpha: 0.22 },\n            { tex: this.texture13, scale: -0.4, alpha: 0.22 },\n        ], this.dirt);\n\n        const texture3: Texture = new Texture(this.accumulationBuffer, framebuffer.width, framebuffer.height);\n        // framebuffer.drawTexture(0, 0, texture3, 0.75);\n        framebuffer.drawScaledTextureClipBi(0, 0, framebuffer.width, framebuffer.height, texture3, .75);\n\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n        framebuffer.noise(time, this.noise, 0.04);\n    }\n\n    public reproduceRazorScene(framebuffer: Framebuffer, elapsedTime: number, texture: Array<{ tex: Texture, scale: number, alpha: number }>, dirt: Texture): void {\n        // camerea:\n        // http://graphicsrunner.blogspot.de/search/label/Water\n        framebuffer.clearColorBuffer(72 | 56 << 8 | 48 << 16 | 255 << 24);\n        framebuffer.clearDepthBuffer();\n\n        let modelViewMartrix: Matrix4f;\n\n        const camera = Matrix4f.constructTranslationMatrix(0, 0, -6.4 - 5 * (Math.sin(elapsedTime * 0.06) * 0.5 + 0.5)).multiplyMatrix(\n            Matrix4f.constructXRotationMatrix((Math.sin(elapsedTime * 0.08) * 0.5 + 0.5) * 0.5).multiplyMatrix(\n                Matrix4f.constructYRotationMatrix(elapsedTime * 0.1)));\n\n        let scale = 2.0;\n        modelViewMartrix = Matrix4f.constructYRotationMatrix(elapsedTime * 0.2).multiplyMatrix(Matrix4f.constructScaleMatrix(scale, scale, scale));\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(0, 1.0, 0).multiplyMatrix(modelViewMartrix.multiplyMatrix(Matrix4f.constructXRotationMatrix(-elapsedTime * 0.2)));\n        modelViewMartrix = camera.multiplyMatrix(\n            modelViewMartrix);\n\n\n        let model = this.dodecahedron.getMesh();\n        this.renderingPipeline.draw(framebuffer, model, modelViewMartrix);\n\n        const yDisplacement = -1.5;\n        const distance = 2.8;\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(distance, yDisplacement + 1.0, distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(modelViewMartrix);\n\n        model = this.icosahedron.getMesh();\n        this.renderingPipeline.draw(framebuffer, model, modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale * 0.5, scale * 2, scale * 0.5);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(-distance, yDisplacement + 1, distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(modelViewMartrix);\n\n        // TODO:  store Mesh inside cube instance and use cube.draw(framebuffer);\n        model = this.cube.getMesh();\n        this.renderingPipeline.draw(framebuffer, model, modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(distance, yDisplacement + 0.5, -distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(modelViewMartrix);\n\n        model = this.cube.getMesh();\n        this.renderingPipeline.draw(framebuffer, model, modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(-distance, yDisplacement + 0.5, -distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(modelViewMartrix);\n\n        model = this.pyramid.getMesh();\n        this.renderingPipeline.draw(framebuffer, model, modelViewMartrix);\n\n        /**\n         * SHADOWS\n         */\n        this.renderingPipeline.enableLighting(false);\n        this.renderingPipeline.setColor(Color.DARK_GRAY);\n\n        scale = 2.0;\n        modelViewMartrix = Matrix4f.constructYRotationMatrix(elapsedTime * 0.2).multiplyMatrix(Matrix4f.constructScaleMatrix(scale, scale, scale));\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(0, 1.0, 0).multiplyMatrix(modelViewMartrix.multiplyMatrix(Matrix4f.constructXRotationMatrix(-elapsedTime * 0.2)));\n        modelViewMartrix = camera.multiplyMatrix(\n            Matrix4f.constructShadowMatrix().multiplyMatrix(modelViewMartrix));\n\n            this.renderingPipeline.draw(framebuffer, this.dodecahedron.getMesh(), modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(-distance, yDisplacement + 0.5, -distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(\n            Matrix4f.constructShadowMatrix().multiplyMatrix(modelViewMartrix));\n\n            this.renderingPipeline.draw(framebuffer, this.pyramid.getMesh(), modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(distance, yDisplacement + 0.5, -distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(\n            Matrix4f.constructShadowMatrix().multiplyMatrix(modelViewMartrix));\n\n            this.renderingPipeline.draw(framebuffer, this.cube.getMesh(), modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale * 0.5, scale * 2, scale * 0.5);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(-distance, yDisplacement + 1, distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(\n            Matrix4f.constructShadowMatrix().multiplyMatrix(modelViewMartrix));\n\n            this.renderingPipeline.draw(framebuffer, this.cube.getMesh(), modelViewMartrix);\n\n        scale = 1.0;\n        modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale);\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(distance, yDisplacement + 1.0, distance).multiplyMatrix(modelViewMartrix);\n        modelViewMartrix = camera.multiplyMatrix(\n            Matrix4f.constructShadowMatrix().multiplyMatrix(modelViewMartrix));\n\n            this.renderingPipeline.draw(framebuffer, this.icosahedron.getMesh(), modelViewMartrix);\n\n        this.renderingPipeline.enableLighting(true);\n\n        const lensflareScreenSpace = framebuffer.project(camera.multiply(new Vector3f(12.0, 4.0, 0)));\n\n        LensFlare.drawLensFlare(framebuffer, lensflareScreenSpace, elapsedTime * 100, texture, dirt);\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { RazorScene } from '../../razor/RazorScene';\n\nexport class Scene19 {\n    private RazorScene: RazorScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.RazorScene = new RazorScene();\n\n        return Promise.all([\n            this.RazorScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.RazorScene.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class Cube extends AbstractGeometricObject {\n\n    public constructor() {\n        super();\n        const a: number = 0.5;\n\n        const points: Array<Vector4f> = [\n            new Vector4f(-a, -a, -a),\n            new Vector4f(a, -a, -a),\n            new Vector4f(a, a, -a),\n            new Vector4f(-a, a, -a),\n            new Vector4f(-a, -a, a),\n            new Vector4f(a, -a, a),\n            new Vector4f(a, a, a),\n            new Vector4f(-a, a, a)\n        ];\n\n        const index: Array<number> = [\n            0, 2, 1, 0, 3, 2, 5, 7, 4, 5, 6, 7, 1, 6, 5, 1, 2, 6, 4, 3, 0, 4, 7, 3, 4, 1, 5, 4, 0, 1, 3, 6, 2, 3, 7, 6\n        ];\n\n        this.buildMesh(points, index);\n    }\n\n}\n","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n","import { Framebuffer } from \"../Framebuffer\";\nimport { Vector3f } from \"../math\";\nimport { Interpolator } from \"../math/Interpolator\";\nimport { Texture } from \"../texture\";\n\nexport class LensFlare {\n\n    public static drawLensFlare(framebuffer: Framebuffer, screenPos: Vector3f, elapsedTime: number, texture: Array<{ tex: Texture, scale: number, alpha: number }>, dirt: Texture): void {\n        const pos = screenPos;\n\n        if (pos.z < 0 &&\n            pos.x > 0 && pos.x < framebuffer.width &&\n            pos.y > 0 && pos.y < framebuffer.height &&\n            framebuffer.wBuffer[pos.x + (pos.y * framebuffer.width)] > (1 / pos.z)) {\n            if (!framebuffer.lensFlareVisible) {\n                framebuffer.lensFlareVisible = true;\n                framebuffer.lensFlareStart = elapsedTime;\n            }\n        } else {\n            if (framebuffer.lensFlareVisible) {\n                framebuffer.lensFlareVisible = false;\n                framebuffer.lensFlareEnd = elapsedTime;\n            }\n        }\n\n        let scale = Interpolator.interpolate(framebuffer.lensFlareStart, framebuffer.lensFlareStart + 100, elapsedTime);\n        if (framebuffer.lensFlareVisible !== true) {\n            scale *= (1 - Interpolator.interpolate(framebuffer.lensFlareEnd, framebuffer.lensFlareEnd + 100, elapsedTime));\n        }\n        const dir = new Vector3f(framebuffer.width / 2, framebuffer.height / 2, 0).sub(pos);\n\n        if (scale > 0) {\n            for (let i = 0; i < texture.length; i++) {\n                const temp = pos.add(dir.mul(texture[i].scale));\n                framebuffer.drawTexture(Math.round(temp.x) - texture[i].tex.width / 2, Math.round(temp.y) - texture[i].tex.height / 2, texture[i].tex, texture[i].alpha * scale);\n            }\n        }\n\n        // this.drawTextureRectAdd(0, 0, 0, 0, this.width, this.height, dirt, 0.03 + 0.15 * scale);\n        framebuffer.drawScaledTextureClipBi(0, 0, framebuffer.width, framebuffer.height, dirt, 0.15 + 0.20 * scale*0);\n    }\n\n}\n"],"names":["Dodecahedron","AbstractGeometricObject","constructor","super","phi","Math","sqrt","b","c","points","Vector4f","this","buildMesh","Pyramid","a","Sphere","xSteps","ySteps","STEPS","STEPS2","i","r","push","sphereFunction","PI","index","j","theta","cos","sin","RazorScene","AbstractScene","texture10","texture11","texture13","dirt","noise","cube","dodecahedron","pyramid","icosahedron","accumulationBuffer","renderingPipeline","init","framebuffer","GouraudShadingRenderingPipeline","Uint32Array","width","height","setCullFace","CullFace","BACK","Cube","Promise","all","TextureUtils","load","then","texture","generateProceduralNoise","render","time","reproduceRazorScene","tex","scale","alpha","texture3","Texture","drawScaledTextureClipBi","fastFramebufferCopy","elapsedTime","modelViewMartrix","clearColorBuffer","clearDepthBuffer","camera","Matrix4f","constructTranslationMatrix","multiplyMatrix","constructXRotationMatrix","constructYRotationMatrix","constructScaleMatrix","model","getMesh","draw","distance","yDisplacement","enableLighting","setColor","Color","DARK_GRAY","constructShadowMatrix","lensflareScreenSpace","project","multiply","Vector3f","LensFlare","drawLensFlare","Scene19","ColorInterpolator","startColor","colorSlope","setup","c1","c2","g","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","fillLongRightTriangle","v1","v2","v3","color","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","yStart","length","round","currentX","framebufferIndex","spanzStep","currentZ","wStart","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","y","x","z","fog","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","Array","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","position","light2","mat","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setFog","setLights","enable","setMaterial","drawMeshArray","meshes","mesh","normalMatrix","computeNormalMatrix","normals","multiplyHomArr","transformedNormals","transformedPoints","faces","normal1","n1","normal2","n2","normal3","n3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","vertex","sub","mul","add","subject","input","S","point","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","computeVertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","normalize","max","dot","v","pow","Light","PointLight","Material","emissiveColor","static","screenPos","pos","lensFlareVisible","lensFlareStart","lensFlareEnd","interpolate","dir","temp","drawTexture"],"sourceRoot":""}