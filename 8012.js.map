{"version":3,"file":"8012.js","mappings":"iKAOO,MAAMA,EAEDC,KACAC,KACAC,MACAC,KACAC,MACAC,GAEAC,0BAAwD,IAAI,IAA2B,MACxFC,OAEH,OAAOC,QAAQC,IAAI,CACf,IAAaC,KAAK,EAAQ,OAAoC,GAAOC,MAChEC,GAAqBC,KAAKb,KAAOY,IAEtC,IAAaF,KAAK,EAAQ,OAAoC,GAAOC,MAChEC,GAAqBC,KAAKZ,KAAOW,IAEtC,IAAaF,KAAK,EAAQ,OAAqC,GAAOC,MACjEC,GAAqBC,KAAKX,MAAQU,IAEvC,IAAaF,KAAK,EAAQ,OAAoC,GAAOC,MAChEC,GAAqBC,KAAKV,KAAOS,IAEtC,IAAaF,KAAK,EAAQ,OAAqC,GAAOC,MACjEC,GAAqBC,KAAKT,MAAQQ,IAEvC,IAAaF,KAAK,EAAQ,OAAkC,GAAOC,MAC9DC,GAAqBC,KAAKR,GAAKO,MAChCD,MAAK,KACLE,KAAKb,KAAKc,UAAS,GACnBD,KAAKZ,KAAKa,UAAS,GACnBD,KAAKX,MAAMY,UAAS,GACpBD,KAAKV,KAAKW,UAAS,GACnBD,KAAKT,MAAMU,UAAS,GACpBD,KAAKR,GAAGS,UAAS,EAAK,GAElC,CAGOC,KAAKC,EAA0BC,GAElCJ,KAAKP,0BAA0BY,eAAeF,GAC9CH,KAAKM,WAAWH,EAAaC,EAAGG,cACpC,CAEOD,WAAWH,EAA0BK,GACxC,MAAMC,EAAQ,GACRC,EAAW,CACbV,KAAKb,KACLa,KAAKV,KACLU,KAAKX,MACLW,KAAKT,OAGT,IAAIoB,EACAP,EACAQ,EAEJ,MAAMC,EAAY,CACd,IAAI,IAAS,EAAG,GAAI,EAAG,GACvB,IAAI,KAAU,EAAG,GAAI,EAAG,GACxB,IAAI,KAAU,GAAI,GAAI,EAAG,GACzB,IAAI,IAAS,EAAG,GAAI,EAAG,GACvB,IAAI,KAAU,GAAI,GAAI,EAAG,GACzB,IAAI,IAAS,GAAI,GAAI,EAAG,IAG5B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACnBH,EACIH,EAASO,eACL,IAASC,yBAAyBC,KAAKC,IAAIH,eACvC,IAASI,yBAAqC,GAAVF,KAAKC,GAAS,EAAIJ,KAGlEV,EAAKO,EAAOI,eAAe,IAASK,qBAAqBX,EAAOA,EAAOA,IAIvEG,EAAkB,CACdS,OAAQR,EACRS,QAAST,EAAUU,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,KAChDC,GAAI,CACA,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,IAE7BC,MAAO,CACH,CACIC,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,IAEf,CACIE,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,MAKvBrB,EAAYwB,WAAWjB,EAASI,IAChCd,KAAKP,0BAA0BY,eAAeF,GAC9CH,KAAKP,0BAA0BmC,mBAAmBxB,GAClDJ,KAAKP,0BAA0BS,KAAKC,EAAaS,GAIrDD,EAASH,EAASO,eACd,IAASC,yBAAyBC,KAAKC,KAAKH,eACxC,IAASI,yBAAyB,GAC7BJ,eAAe,IAASI,yBAAmC,EAAVF,KAAKC,GAAS,EAAI,GAAGH,eAAe,IAASC,yBAAoC,GAAVC,KAAKC,GAAS,MAInJd,EAAKO,EAAOI,eAAe,IAASK,qBAAqBX,EAAOA,EAAOA,IAGvEG,EAAkB,CAEdS,OAAQR,EACRS,QAAST,EAAUU,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,KAChDC,GAAI,CACA,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,IAE7BC,MAAO,CACH,CACIC,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,IAEf,CACIE,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,MAKvBrB,EAAYwB,WAAW3B,KAAKR,IAC5BQ,KAAKP,0BAA0BmC,mBAAmBxB,GAClDJ,KAAKP,0BAA0BS,KAAKC,EAAaS,GAGjDD,EACIH,EAASO,eACL,IAASC,yBAAyBC,KAAKC,KAAKH,eACxC,IAASI,yBAAyB,GAC7BJ,eAAe,IAASI,yBAAmC,EAAVF,KAAKC,GAAS,GAAGH,eAAe,IAASC,yBAAmC,EAAVC,KAAKC,GAAS,MAKlJd,EAAKO,EAAOI,eAAe,IAASK,qBAAqBX,EAAOA,EAAOA,IAGvEG,EAAkB,CACdS,OAAQR,EACRS,QAAST,EAAUU,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,KAChDC,GAAI,CACA,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,GACzB,IAAI,IAAkB,EAAG,IAE7BC,MAAO,CACH,CACIC,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,IAEf,CACIE,SAAU,CAAC,EAAG,EAAG,GACjBF,GAAI,CAAC,EAAG,EAAG,MAKvBrB,EAAYwB,WAAW3B,KAAKZ,MAC5BY,KAAKP,0BAA0BmC,mBAAmBxB,GAClDJ,KAAKP,0BAA0BS,KAAKC,EAAaS,EACrD,E,oECtLG,MAAMiB,EAEFC,aAAaC,EAA4BC,GAAkB,GAC9D,MAAMC,EAA+B,GAuCrC,OArCAF,EAAaG,SAASC,IAClB,MAAMd,EAA0B,IAAIe,MAC9BC,EAA2B,IAAID,MAErCD,EAAOT,SAASQ,SAASI,IACrBjB,EAAOkB,KAAK,IAAI,IAASD,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAGC,IAAI,GAAG,IAGnDR,EAAOE,QAAQH,SAASI,IACpBD,EAAQE,KACJP,EAAS,IAAI,IAASM,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAGE,YAAYD,KAAK,GAAK,IAAI,IAASL,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAGE,YAC1F,IAGL,MAAMnB,EAA+B,GACrCU,EAAOV,MAAMS,SAASW,IAClBpB,EAAMc,KAAK,CACPO,GAAID,EAAER,QAAQ,GACdU,GAAIF,EAAER,QAAQ,GACdW,GAAIH,EAAER,QAAQ,GACdY,GAAIJ,EAAEnB,SAAS,GACfwB,GAAIL,EAAEnB,SAAS,GACfyB,GAAIN,EAAEnB,SAAS,IACjB,IAGN,MAAM0B,EAAsB,CACxB3B,QACAY,UACAhB,SACAgC,mBAAoBhB,EAAQd,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,EAAG,KAC5D+B,kBAAmBjC,EAAOE,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,EAAG,MAG9DU,EAAMM,KAAKa,EAAI,IAGZnB,CACX,CAEOH,uBACHyB,EAAoBC,GAAgB,GACpC,MAAMvB,EAA6B,GA8CnC,OA5CAsB,EAAKrB,SAASC,IACV,MAAMd,EAA0B,IAAIe,MAC9BC,EAA2B,IAAID,MACrC,IAAIqB,EAEAtB,EAAOX,KACPiC,EAAS,GACTtB,EAAOX,GAAGU,SAASI,IACf,MAAMd,EAAwB,IAAI,IAClCA,EAAGkC,EAAIpB,EAAEoB,EACTlC,EAAGc,EAAI,EAAMA,EAAEA,EACfmB,EAAOlB,KAAKf,EAAG,KAIvBW,EAAOT,SAASQ,SAASI,IAEjBkB,EACAnC,EAAOkB,KAAK,IAAI,IAASD,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAGC,IAAI,GAAGgB,IAAI,IAAI,IAAS,GAAI,IAAK,EAAG,KAE5EtC,EAAOkB,KAAK,IAAI,IAASD,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAGC,IAAI,GAAG,IAGvDR,EAAOE,QAAQH,SAASI,IACpBD,EAAQE,KAAK,IAAI,IAASD,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAAG,IAG7C,MAAMkB,GAAS,IAAI,KAA6BC,sBAAsBxC,GACtEuC,EAAOE,YAAYC,EAAI,EAGvB,MAAMX,EAAM,CACR/B,SACAgB,UACAb,GAAIiC,EACJhC,MAAOU,EAAOV,MACdH,QAASD,EAAOE,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,EAAG,KAChDyC,SAAU3B,EAAQd,KAAI,IAAM,IAAI,IAAS,EAAG,EAAG,EAAG,KAClD0C,eAAgBL,EAChBM,KAAM/B,EAAO+B,MAEjBjC,EAAMM,KAAKa,EAAI,IAGZnB,CACX,E,oJC/FG,MAAMkC,UAAwBC,EAAA,EAEzBC,WACAC,UACAC,UACAC,MACAC,KACAC,OAEAC,gBAEAC,mBACAnF,0BAEDC,KAAKS,GASR,OARAH,KAAKP,0BAA4B,IAAIoF,EAAA,EAA2B1E,GAChEH,KAAK4E,mBAAqB,IAAIE,YAAY3E,EAAY4E,MAAQ5E,EAAY6E,QAC1E7E,EAAY8E,YAAYC,EAAA,EAASC,MACjCnF,KAAK0E,OAAS,IAAIxF,EAAA,EAKXS,QAAQC,IAAI,CACfI,KAAK0E,OAAOhF,OACZ0F,EAAA,EAAcC,gBAAgB,EAAQ,OAAoCvF,MACrEwF,GAA8BtF,KAAK2E,gBAAkBW,IAE1DC,EAAA,EAAa1F,KAAK,EAAQ,OAAgC,GAAOC,MAC5DC,GAAqBC,KAAKqE,WAAatE,IAE5CwF,EAAA,EAAa1F,KAAK,EAAQ,OAA0B,GAAMC,MACrDC,GAAqBC,KAAKsE,UAAYvE,IAE3CwF,EAAA,EAAa1F,KAAK,EAAQ,MAA2B,GAAMC,MACtDC,GAAqBC,KAAKuE,UAAYxE,IAE3CwF,EAAA,EAAaC,0BAA0B1F,MAClCC,GAAqBC,KAAKwE,MAAQzE,IAEvCwF,EAAA,EAAa1F,KAAK,EAAQ,OAA0B,GAAMC,MACrDC,GAAqBC,KAAKyE,KAAO1E,KAG9C,CAEO0F,OAAOtF,EAA0BuF,GACpC1F,KAAKP,0BAA0BwF,YAAYC,EAAA,EAASC,MACpD,MAAMQ,EAAsB,GAAMD,EAElCvF,EAAYyF,mBAEZ,MAAMjF,EAAmBX,KAAK6F,sBAAsBF,GAC9CvF,EAAeO,EAAOI,eAAe+E,EAAA,EAAS1E,qBAAqB,EAAG,EAAG,IAE/EpB,KAAK0E,OAAOxE,KAAKC,EAAaC,GAE9BD,EAAYyF,mBACZzF,EAAYwB,WAAW3B,KAAKqE,YAE5B,MAAM0B,EAAgD/F,KAAKP,0BAE3DsG,EAAkBnE,mBAAmBxB,GACrC2F,EAAkBC,cAAc7F,EAAaH,KAAK2E,iBAElD,MACMsB,EACF9F,EAAY+F,QAAQvF,EAAOJ,cAAc4F,SAAS,IAAIC,EAAA,EAAS,GAAa,IAAW,MAE3FC,EAAA,EAAUC,cAAcnG,EAAa8F,EAAoC,IAAdN,EAAmB,CAC1E,CAAEY,IAAKvG,KAAKsE,UAAWkC,MAAO,IAAKC,MAAO,IAC1C,CAAEF,IAAKvG,KAAKuE,UAAWiC,MAAO,IAAKC,MAAO,KAC1C,CAAEF,IAAKvG,KAAKuE,UAAWiC,MAAO,GAAKC,MAAO,KAC1C,CAAEF,IAAKvG,KAAKuE,UAAWiC,OAAQ,GAAKC,MAAO,MAC5CzG,KAAKyE,MAER,MAAMiC,EAAoB,IAAIC,EAAA,EAAQ3G,KAAK4E,mBAAoBzE,EAAY4E,MAAO5E,EAAY6E,QAC9F7E,EAAYyG,YAAY,EAAG,EAAGF,EAAU,KACxCvG,EAAY0G,oBAAoB7G,KAAK4E,mBAAoBzE,EAAYA,aACrEA,EAAYqE,MAAMkB,EAAM1F,KAAKwE,MACjC,CAEQqB,sBAAsBF,GAC1B,OAAOG,EAAA,EAASgB,2BAA2B,EAAG,EAA0D,IAAb,GAAlC7F,KAAK8F,IAAkB,KAAdpB,GAA+B,IAA/C,KAC7C5E,eACG+E,EAAA,EAAS9E,yBAAuC,KAAd2E,GAAsB5E,eACpD+E,EAAA,EAAS3E,yBAAwC,MAAdwE,GAAsB5E,eACrD+E,EAAA,EAASgB,2BAA2B,EAAG,EAAG,KAI9D,ECnGG,MAAME,EACD7C,gBACDzE,KAAKS,GAIR,OAFAH,KAAKmE,gBAAkB,IAAIA,EAEpBxE,QAAQC,IAAI,CACfI,KAAKmE,gBAAgBzE,KAAKS,IAElC,CAEOsF,OAAOtF,EAA0BuF,GACpC1F,KAAKmE,gBAAgBsB,OAAOtF,EAAauF,EAC7C,E,0DCbG,MAAMuB,EAEFpD,sBAAsBnC,GAEzB,GAAwB,IAApBA,EAASwF,OACT,MAAM,IAAIC,MAAM,kCAGpB,GAAwB,IAApBzF,EAASwF,OACT,OAAO,IAAI,IAAOxF,EAAS,GAAI,GAGnC,IAAI0F,EAAS,IAAI,IAAS,EAAG,EAAG,EAAG,GAC/BC,EAAS,EAYb,OAVA3F,EAASQ,SAAQoF,IACbF,EAASA,EAAOzD,IAAI,IAAI,IAAS2D,EAAM9E,EAAG8E,EAAM7E,EAAG6E,EAAM5E,EAAG,GAAK,IAGrE0E,EAASA,EAAOzE,IAAI,EAAMjB,EAASwF,QAEnCxF,EAASQ,SAAQoF,IACbD,EAASpG,KAAKsG,IAAIF,EAAQD,EAAOI,IAAIF,GAAOJ,SAAS,IAGlD,IAAI,IAAOE,EAAQC,EAC9B,E,kCCxBG,MAAMI,EAEDL,OACAC,OAER,YAAmBK,EAAoBL,GACnCrH,KAAKoH,OAASM,EACd1H,KAAKqH,OAASA,CAClB,CAQOM,0BAA0BC,GAC7B,OAAOA,EAAMC,YAAYC,IAAI9H,KAAKoH,QAAUQ,EAAMG,eAAkB/H,KAAKqH,MAC7E,CAEOW,QAAQC,GACX,OAAOA,EAAIC,YAAYlI,KAAKoH,OAChC,CAEOe,YACH,OAAOnI,KAAKqH,MAChB,CAEOvD,YACH,OAAO9D,KAAKoH,MAChB,E,+CCzBG,MAAMhC,EAEFtD,YAAYsG,GACf,OAAOC,MAAMD,GAAUtI,MAAMwI,GAClBA,EAASC,SACjBzI,MAAM0I,GACE,IAAkBC,MAAMD,IAEvC,CAEO1G,uBAAuBsG,GAC1B,OAAOC,MAAMD,GAAUtI,MAAMwI,GAClBA,EAASC,SACjBzI,MAAM0I,GACE,IAAkBE,gBAAgBF,GAAQ,IAEzD,CAEA,cAEA,E,0DCzBG,MAAMnC,EAEFvE,qBAAqB3B,EAA0BwI,EAAqBhD,EAAqB5F,EAAgE0E,GAC5J,MAAMmE,EAAMD,EAERC,EAAIlG,EAAI,GACRkG,EAAIpG,EAAI,GAAKoG,EAAIpG,EAAIrC,EAAY4E,OACjC6D,EAAInG,EAAI,GAAKmG,EAAInG,EAAItC,EAAY6E,QACjC7E,EAAY0I,QAAQD,EAAIpG,EAAKoG,EAAInG,EAAItC,EAAY4E,OAAW,EAAI6D,EAAIlG,EAC/DvC,EAAY2I,mBACb3I,EAAY2I,kBAAmB,EAC/B3I,EAAY4I,eAAiBpD,GAG7BxF,EAAY2I,mBACZ3I,EAAY2I,kBAAmB,EAC/B3I,EAAY6I,aAAerD,GAInC,IAAIa,EAAQ,IAAayC,YAAY9I,EAAY4I,eAAgB5I,EAAY4I,eAAiB,IAAKpD,IAC9D,IAAjCxF,EAAY2I,mBACZtC,GAAU,EAAI,IAAayC,YAAY9I,EAAY6I,aAAc7I,EAAY6I,aAAe,IAAKrD,IAErG,MAAMuD,EAAM,IAAI,IAAS/I,EAAY4E,MAAQ,EAAG5E,EAAY6E,OAAS,EAAG,GAAGwC,IAAIoB,GAE/E,GAAIpC,EAAQ,EACR,IAAK,IAAI1F,EAAI,EAAGA,EAAIf,EAAQmH,OAAQpG,IAAK,CACrC,MAAMqI,EAAOP,EAAIjF,IAAIuF,EAAIvG,IAAI5C,EAAQe,GAAG0F,QACxCrG,EAAYyG,YAAY3F,KAAKmI,MAAMD,EAAK3G,GAAKzC,EAAQe,GAAGyF,IAAIxB,MAAQ,EAAG9D,KAAKmI,MAAMD,EAAK1G,GAAK1C,EAAQe,GAAGyF,IAAIvB,OAAS,EAAGjF,EAAQe,GAAGyF,IAAKxG,EAAQe,GAAG2F,MAAQD,E,CAKlKrG,EAAYkJ,wBAAwB,EAAG,EAAGlJ,EAAY4E,MAAO5E,EAAY6E,OAAQP,EAAM,IAAO,GAAO+B,EAAM,EAC/G,E","sources":["webpack://aisa/./src/SkyBox.ts","webpack://aisa/./src/blender/BlenderJsonParser.ts","webpack://aisa/./src/examples/metalheadz/MetalHeadzScene.ts","webpack://aisa/./src/examples/demo/parts/Scene10.ts","webpack://aisa/./src/math/Geometry.ts","webpack://aisa/./src/math/Sphere.ts","webpack://aisa/./src/model/blender/BlenderLoader.ts","webpack://aisa/./src/special-effects/LensFlare.ts"],"sourcesContent":["import { Framebuffer } from './Framebuffer';\nimport { Matrix4f, Vector4f } from './math';\nimport { Texture, TextureUtils } from './texture';\nimport { TextureCoordinate } from './TextureCoordinate';\nimport { TexturingRenderingPipeline } from './rendering-pipelines/TexturingRenderingPipeline';\nimport { TexturedMesh } from './rendering-pipelines/TexturedMesh';\n\nexport class SkyBox {\n\n    private back: Texture;\n    private down: Texture;\n    private front: Texture;\n    private left: Texture;\n    private right: Texture;\n    private up: Texture;\n\n    private texturedRenderingPipeline: TexturingRenderingPipeline = new TexturingRenderingPipeline(null);\n    public init(): Promise<any> {\n\n        return Promise.all([\n            TextureUtils.load(require('./assets/skybox/skybox_back.png'), false).then(\n                (texture: Texture) => this.back = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_down.png'), false).then(\n                (texture: Texture) => this.down = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_front.png'), false).then(\n                (texture: Texture) => this.front = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_left.png'), false).then(\n                (texture: Texture) => this.left = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_right.png'), false).then(\n                (texture: Texture) => this.right = texture\n            ),\n            TextureUtils.load(require('./assets/skybox/skybox_up.png'), false).then(\n                (texture: Texture) => this.up = texture\n            )]).then(() => {\n                this.back.setClamp(true);\n                this.down.setClamp(true);\n                this.front.setClamp(true);\n                this.left.setClamp(true);\n                this.right.setClamp(true);\n                this.up.setClamp(true);\n            });\n    }\n\n    // move code from framebuffer into draw method!\n    public draw(framebuffer: Framebuffer, mv: Matrix4f): void {\n    \n        this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n        this.drawSkyBox(framebuffer, mv.getRotation());\n    }\n\n    public drawSkyBox(framebuffer: Framebuffer, rotation: Matrix4f): void {\n        const sclae = 20;\n        const textures = [\n            this.back,\n            this.left,\n            this.front,\n            this.right\n        ];\n\n        let camera: Matrix4f;\n        let mv: Matrix4f;\n        let skyBoxSideModel: TexturedMesh;\n\n        const skyPoints = [\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, 1, -1, 1),\n            new Vector4f(-1, -1, -1, 1),\n            new Vector4f(1, -1, -1, 1)\n        ];\n\n        for (let i = 0; i < 4; i++) {\n            camera =\n                rotation.multiplyMatrix(\n                    Matrix4f.constructXRotationMatrix(Math.PI).multiplyMatrix(\n                        Matrix4f.constructYRotationMatrix(+ Math.PI * 2 / 4 * i)));\n\n\n            mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n\n            // skybox: starz\n            skyBoxSideModel = {\n                points: skyPoints,\n                points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n                uv: [\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 1),\n                    new TextureCoordinate(0, 0),\n                    new TextureCoordinate(1, 0),\n                ],\n                faces: [\n                    {\n                        vertices: [0, 1, 2],\n                        uv: [0, 1, 2]\n                    },\n                    {\n                        vertices: [3, 4, 5],\n                        uv: [3, 4, 5]\n                    }\n                ]\n            };\n\n            framebuffer.setTexture(textures[i]);\n            this.texturedRenderingPipeline.setFramebuffer(framebuffer);\n            this.texturedRenderingPipeline.setModelViewMatrix(mv);\n            this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n        }\n\n        camera = rotation.multiplyMatrix(\n            Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                Matrix4f.constructYRotationMatrix(0)\n                    .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 4 * 1).multiplyMatrix(Matrix4f.constructXRotationMatrix(-Math.PI * 2 / 4)))\n            );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.up);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n\n\n        camera =\n            rotation.multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(Math.PI)).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(0)\n                        .multiplyMatrix(Matrix4f.constructYRotationMatrix(Math.PI * 2 / 2).multiplyMatrix(Matrix4f.constructXRotationMatrix(Math.PI * 2 / 4)))\n\n                );\n\n\n        mv = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(sclae, sclae, sclae));\n\n        // skybox: starz\n        skyBoxSideModel = {\n            points: skyPoints,\n            points2: skyPoints.map(() => new Vector4f(0, 0, 0)),\n            uv: [\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 1),\n                new TextureCoordinate(0, 0),\n                new TextureCoordinate(1, 0),\n            ],\n            faces: [\n                {\n                    vertices: [0, 1, 2],\n                    uv: [0, 1, 2]\n                },\n                {\n                    vertices: [3, 4, 5],\n                    uv: [3, 4, 5]\n                }\n            ]\n        };\n\n        framebuffer.setTexture(this.down);\n        this.texturedRenderingPipeline.setModelViewMatrix(mv);\n        this.texturedRenderingPipeline.draw(framebuffer, skyBoxSideModel);\n    }\n\n}\n","import { FlatShadedFace } from '../geometrical-objects/FlatShadedFace';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { BlenderScene } from './BlenderScene';\nimport { Face } from './face';\nimport { Mesh } from './mesh';\nimport { Vector } from './vector';\nimport { TexturedMesh } from '../rendering-pipelines/TexturedMesh';\nimport { TextureCoordinate } from '../TextureCoordinate';\nimport { ComputationalGeometryUtils } from '../math/Geometry';\nimport { TexCoord } from './tex-coord';\n\nexport class BlenderJsonParser {\n\n    public static parse(blenderScene: BlenderScene, invert: boolean = false): Array<FlatshadedMesh> {\n        const scene: Array<FlatshadedMesh> = [];\n\n        blenderScene.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n\n            object.vertices.forEach((v: Vector) => {\n                points.push(new Vector4f(v.x, v.y, v.z).mul(1));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(\n                    invert ? new Vector4f(v.x, v.y, v.z).normalize().mul(-1) : new Vector4f(v.x, v.y, v.z).normalize()\n                );\n            });\n\n            const faces: Array<FlatShadedFace> = [];\n            object.faces.forEach((f: Face) => {\n                faces.push({\n                    n1: f.normals[0],\n                    n2: f.normals[1],\n                    n3: f.normals[2],\n                    v1: f.vertices[0],\n                    v2: f.vertices[1],\n                    v3: f.vertices[2],\n                });\n            });\n\n            const obj: FlatshadedMesh = {\n                faces,\n                normals,\n                points,\n                transformedNormals: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                transformedPoints: points.map(() => new Vector4f(0, 0, 0, 0)),\n            };\n\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n    public static getBlenderScene(\n        file: BlenderScene, disp: boolean = true): Array<TexturedMesh> {\n        const scene: Array<TexturedMesh> = [];\n\n        file.forEach((object: Mesh) => {\n            const points: Array<Vector4f> = new Array<Vector4f>();\n            const normals: Array<Vector4f> = new Array<Vector4f>();\n            let coords: Array<TextureCoordinate>;\n\n            if (object.uv) {\n                coords = [];\n                object.uv.forEach((v: TexCoord) => {\n                    const uv: TextureCoordinate = new TextureCoordinate();\n                    uv.u = v.u;\n                    uv.v = 1.0 - v.v;\n                    coords.push(uv);\n                });\n            }\n\n            object.vertices.forEach((v: Vector) => {\n                // some transformation in order for the vertices to be in worldspace\n                if (disp)\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2).add(new Vector4f(0, -2.7, 0, 0)));\n                else\n                    points.push(new Vector4f(v.x, v.y, v.z).mul(2));\n            });\n\n            object.normals.forEach((v: Vector) => {\n                normals.push(new Vector4f(v.x, v.y, v.z));\n            });\n\n            const sphere = new ComputationalGeometryUtils().computeBoundingSphere(points);\n            sphere.getCenter().w = 1;\n\n            // Create class for objects\n            const obj = {\n                points,\n                normals,\n                uv: coords,           // NO!!!\n                faces: object.faces, // NOO!!!\n                points2: points.map(() => new Vector4f(0, 0, 0, 0)),\n                normals2: normals.map(() => new Vector4f(0, 0, 0, 0)),\n                boundingSphere: sphere, // NO!!!\n                name: object.name /// NO!\n            };\n            scene.push(obj);\n        });\n\n        return scene;\n    }\n\n}\n","import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { Matrix4f, Vector3f } from '../../math';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { SkyBox } from '../../SkyBox';\nimport { Texture, TextureUtils } from '../../texture';\nimport { TexturingRenderingPipeline } from '../../rendering-pipelines/TexturingRenderingPipeline';\nimport { BlenderLoader } from '../../model/blender/BlenderLoader';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { LensFlare } from '../../special-effects/LensFlare';\n\nexport class MetalHeadzScene extends AbstractScene {\n\n    private metalheadz: Texture;\n    private texture11: Texture;\n    private texture13: Texture;\n    private noise: Texture;\n    private dirt: Texture;\n    private skyBox: SkyBox;\n\n    private blenderObjMetal: any;\n\n    private accumulationBuffer: Uint32Array;\n    private texturedRenderingPipeline: TexturingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.texturedRenderingPipeline = new TexturingRenderingPipeline(framebuffer);\n        this.accumulationBuffer = new Uint32Array(framebuffer.width * framebuffer.height);\n        framebuffer.setCullFace(CullFace.BACK);\n        this.skyBox = new SkyBox();\n        // TODO:\n        // make classes for assets\n        // lens flare, 3d modell\n\n        return Promise.all([\n            this.skyBox.init(),\n            BlenderLoader.loadWithTexture(require('../../assets/jsx/metalheadz.jsx')).then(\n                (mesh: Array<TexturedMesh>) => this.blenderObjMetal = mesh\n            ),\n            TextureUtils.load(require('../../assets/metalheadz.png'), false).then(\n                (texture: Texture) => this.metalheadz = texture\n            ),\n            TextureUtils.load(require('../../assets/ring.png'), true).then(\n                (texture: Texture) => this.texture11 = texture\n            ),\n            TextureUtils.load(require('../../assets/bokeh.png'), true).then(\n                (texture: Texture) => this.texture13 = texture\n            ),\n            TextureUtils.generateProceduralNoise().then(\n                (texture: Texture) => this.noise = texture\n            ),\n            TextureUtils.load(require('../../assets/dirt.png'), true).then(\n                (texture: Texture) => this.dirt = texture\n            ),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.texturedRenderingPipeline.setCullFace(CullFace.BACK);\n        const elapsedTime: number = 0.2 * time;\n\n        framebuffer.clearDepthBuffer();\n\n        const camera: Matrix4f = this.computeCameraMovement(elapsedTime);\n        const mv: Matrix4f = camera.multiplyMatrix(Matrix4f.constructScaleMatrix(7, 7, 7));\n\n        this.skyBox.draw(framebuffer, mv);\n\n        framebuffer.clearDepthBuffer();\n        framebuffer.setTexture(this.metalheadz);\n\n        const renderingPipeline: TexturingRenderingPipeline = this.texturedRenderingPipeline;\n\n        renderingPipeline.setModelViewMatrix(mv);\n        renderingPipeline.drawMeshArray(framebuffer, this.blenderObjMetal);\n\n        const scale: number = 20;\n        const lensflareScreenSpace: Vector3f =\n            framebuffer.project(camera.getRotation().multiply(new Vector3f(1.1 * scale, 2 * scale, -0.9 * scale)));\n\n        LensFlare.drawLensFlare(framebuffer, lensflareScreenSpace, elapsedTime * 1.2, [\n            { tex: this.texture11, scale: 2.3, alpha: 0.5 },\n            { tex: this.texture13, scale: 1.6, alpha: 0.25 },\n            { tex: this.texture13, scale: 0.7, alpha: 0.22 },\n            { tex: this.texture13, scale: -0.4, alpha: 0.22 },\n        ], this.dirt);\n\n        const texture3: Texture = new Texture(this.accumulationBuffer, framebuffer.width, framebuffer.height);\n        framebuffer.drawTexture(0, 0, texture3, 0.75);\n        framebuffer.fastFramebufferCopy(this.accumulationBuffer, framebuffer.framebuffer);\n        framebuffer.noise(time, this.noise);\n    }\n\n    private computeCameraMovement(elapsedTime: number): Matrix4f {\n        return Matrix4f.constructTranslationMatrix(0, 0, -134 + (Math.sin(elapsedTime * 0.00007) * 0.5 + 0.5) * 17)\n            .multiplyMatrix(\n                Matrix4f.constructXRotationMatrix(elapsedTime * 0.0008).multiplyMatrix(\n                    Matrix4f.constructYRotationMatrix(-elapsedTime * 0.0009).multiplyMatrix(\n                        Matrix4f.constructTranslationMatrix(0, 0, 0)\n                    )\n                )\n            );\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { MetalHeadzScene } from '../../metalheadz/MetalHeadzScene';\n\nexport class Scene10 {\n    private MetalHeadzScene: MetalHeadzScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.MetalHeadzScene = new MetalHeadzScene();\n\n        return Promise.all([\n            this.MetalHeadzScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.MetalHeadzScene.render(framebuffer, time);\n    }\n\n}","import { Vector4f } from './index';\nimport { Sphere } from './Sphere';\n\nexport class ComputationalGeometryUtils {\n\n    public computeBoundingSphere(vertices: Array<Vector4f>): Sphere {\n\n        if (vertices.length === 0) {\n            throw new Error('More than one vertex required.');\n        }\n\n        if (vertices.length === 1) {\n            return new Sphere(vertices[0], 0);\n        }\n\n        let center = new Vector4f(0, 0, 0, 0);\n        let radius = 0;\n\n        vertices.forEach(point => {\n            center = center.add(new Vector4f(point.x, point.y, point.z, 0.0));\n        });\n\n        center = center.mul(1.0 / vertices.length);\n\n        vertices.forEach(point => {\n            radius = Math.max(radius, center.sub(point).length());\n        });\n\n        return new Sphere(center, radius);\n    }\n\n}\n","import { BoundingVolume } from './BoundingVolume';\nimport { Vector4f } from './index';\nimport { Matrix4f } from './Matrix4f';\nimport { Plane } from './Plane';\n\nexport class Sphere implements BoundingVolume {\n\n    private center: Vector4f;\n    private radius: number;\n\n    public constructor(position: Vector4f, radius: number) {\n        this.center = position;\n        this.radius = radius;\n    }\n\n    /**\n     *\n     * @param {Plane} plane\n     * @returns {boolean}\n     * @memberof Sphere\n     */\n    public isInsidePositiveHalfSpace(plane: Plane): boolean {\n        return plane.getNormal().dot(this.center) - plane.getDistance() > - this.radius;\n    }\n\n    public getTran(mat: Matrix4f): Vector4f {\n        return mat.multiplyHom(this.center);\n    }\n\n    public getRadius(): number {\n        return this.radius;\n    }\n\n    public getCenter(): Vector4f {\n        return this.center;\n    }\n\n}\n","import { BlenderJsonParser } from '../../blender/BlenderJsonParser';\nimport { FlatshadedMesh } from '../../geometrical-objects/FlatshadedMesh';\nimport { TexturedMesh } from '../../rendering-pipelines/TexturedMesh';\nimport { BlenderScene } from '../../blender/BlenderScene';\n\n/**\n * Load Wavefront OBJ file that was converted via obj2json utility.\n * to save the convertToMeshArray step\n * renamed to JSX file to load file at runtime\n */\nexport class BlenderLoader {\n\n    public static load(filename: string): Promise<Array<FlatshadedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.parse(meshes);\n        });\n    }\n\n    public static loadWithTexture(filename: string): Promise<Array<TexturedMesh>> {\n        return fetch(filename).then((response: Response) => {\n            return response.json();\n        }).then((meshes: BlenderScene) => {\n            return BlenderJsonParser.getBlenderScene(meshes, false);\n        });\n    }\n\n    private constructor() {\n\n    }\n}\n","import { Framebuffer } from \"../Framebuffer\";\nimport { Vector3f } from \"../math\";\nimport { Interpolator } from \"../math/Interpolator\";\nimport { Texture } from \"../texture\";\n\nexport class LensFlare {\n\n    public static drawLensFlare(framebuffer: Framebuffer, screenPos: Vector3f, elapsedTime: number, texture: Array<{ tex: Texture, scale: number, alpha: number }>, dirt: Texture): void {\n        const pos = screenPos;\n\n        if (pos.z < 0 &&\n            pos.x > 0 && pos.x < framebuffer.width &&\n            pos.y > 0 && pos.y < framebuffer.height &&\n            framebuffer.wBuffer[pos.x + (pos.y * framebuffer.width)] > (1 / pos.z)) {\n            if (!framebuffer.lensFlareVisible) {\n                framebuffer.lensFlareVisible = true;\n                framebuffer.lensFlareStart = elapsedTime;\n            }\n        } else {\n            if (framebuffer.lensFlareVisible) {\n                framebuffer.lensFlareVisible = false;\n                framebuffer.lensFlareEnd = elapsedTime;\n            }\n        }\n\n        let scale = Interpolator.interpolate(framebuffer.lensFlareStart, framebuffer.lensFlareStart + 100, elapsedTime);\n        if (framebuffer.lensFlareVisible !== true) {\n            scale *= (1 - Interpolator.interpolate(framebuffer.lensFlareEnd, framebuffer.lensFlareEnd + 100, elapsedTime));\n        }\n        const dir = new Vector3f(framebuffer.width / 2, framebuffer.height / 2, 0).sub(pos);\n\n        if (scale > 0) {\n            for (let i = 0; i < texture.length; i++) {\n                const temp = pos.add(dir.mul(texture[i].scale));\n                framebuffer.drawTexture(Math.round(temp.x) - texture[i].tex.width / 2, Math.round(temp.y) - texture[i].tex.height / 2, texture[i].tex, texture[i].alpha * scale);\n            }\n        }\n\n        // this.drawTextureRectAdd(0, 0, 0, 0, this.width, this.height, dirt, 0.03 + 0.15 * scale);\n        framebuffer.drawScaledTextureClipBi(0, 0, framebuffer.width, framebuffer.height, dirt, 0.15 + 0.20 * scale*0);\n    }\n\n}\n"],"names":["SkyBox","back","down","front","left","right","up","texturedRenderingPipeline","init","Promise","all","load","then","texture","this","setClamp","draw","framebuffer","mv","setFramebuffer","drawSkyBox","getRotation","rotation","sclae","textures","camera","skyBoxSideModel","skyPoints","i","multiplyMatrix","constructXRotationMatrix","Math","PI","constructYRotationMatrix","constructScaleMatrix","points","points2","map","uv","faces","vertices","setTexture","setModelViewMatrix","BlenderJsonParser","static","blenderScene","invert","scene","forEach","object","Array","normals","v","push","x","y","z","mul","normalize","f","n1","n2","n3","v1","v2","v3","obj","transformedNormals","transformedPoints","file","disp","coords","u","add","sphere","computeBoundingSphere","getCenter","w","normals2","boundingSphere","name","MetalHeadzScene","AbstractScene","metalheadz","texture11","texture13","noise","dirt","skyBox","blenderObjMetal","accumulationBuffer","TexturingRenderingPipeline","Uint32Array","width","height","setCullFace","CullFace","BACK","BlenderLoader","loadWithTexture","mesh","TextureUtils","generateProceduralNoise","render","time","elapsedTime","clearDepthBuffer","computeCameraMovement","Matrix4f","renderingPipeline","drawMeshArray","lensflareScreenSpace","project","multiply","Vector3f","LensFlare","drawLensFlare","tex","scale","alpha","texture3","Texture","drawTexture","fastFramebufferCopy","constructTranslationMatrix","sin","Scene10","ComputationalGeometryUtils","length","Error","center","radius","point","max","sub","Sphere","position","isInsidePositiveHalfSpace","plane","getNormal","dot","getDistance","getTran","mat","multiplyHom","getRadius","filename","fetch","response","json","meshes","parse","getBlenderScene","screenPos","pos","wBuffer","lensFlareVisible","lensFlareStart","lensFlareEnd","interpolate","dir","temp","round","drawScaledTextureClipBi"],"sourceRoot":""}