{"version":3,"file":"9167.js","mappings":"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","sources":["webpack://aisa/./src/geometrical-objects/TorusKnot.ts","webpack://aisa/./src/shading/fog/Fog.ts","webpack://aisa/./src/shading/fog/LinearFog.ts","webpack://aisa/./src/examples/torus-knot-tunnel/TorusKnotTunnelScene.ts","webpack://aisa/./src/examples/demo/parts/Scene13.ts","webpack://aisa/./src/rasterizer/ColorInterpolator.ts","webpack://aisa/./src/rasterizer/GouraudShadingTriangleRasterizer.ts","webpack://aisa/./src/rasterizer/SlopeInterpolator.ts","webpack://aisa/./src/rendering-pipelines/GouraudShadingRenderingPipeline.ts","webpack://aisa/./src/screen-space-clipping/SutherlandHodgman2DClipper.ts","webpack://aisa/./src/shading/illumination-models/PhongLighting.ts","webpack://aisa/./src/shading/light/Light.ts","webpack://aisa/./src/shading/light/PointLight.ts","webpack://aisa/./src/shading/material/Material.ts"],"sourcesContent":["import { Vector4f } from '../math/Vector4f';\nimport { AbstractGeometricObject } from './AbstractGeometricObject';\n\nexport class TorusKnot extends AbstractGeometricObject {\n\n    public constructor(inverse: boolean = false) {\n        super();\n\n        const points: Array<Vector4f> = [];\n\n        const STEPS = 80;\n        const STEPS2 = 8;\n        for (let i = 0; i < STEPS; i++) {\n            const frame = this.torusFunction3(i * 2 * Math.PI / STEPS);\n            const frame2 = this.torusFunction3(i * 2 * Math.PI / STEPS + 0.1);\n\n            const tangent = frame2.sub(frame);\n            let up = frame.add(frame2).normalize();\n            const right = tangent.cross(up).normalize().mul(26.4);\n            up = right.cross(tangent).normalize().mul(26.4);\n\n            for (let r = 0; r < STEPS2; r++) {\n                const pos = up.mul(Math.sin(r * 2 * Math.PI / STEPS2)).add(right.mul(Math.cos(r * 2 * Math.PI / STEPS2))).add(frame);\n                points.push(pos.mul(1));\n            }\n        }\n\n        const index: Array<number> = [];\n\n\n\n        for (let j = 0; j < STEPS; j++) {\n            for (let i = 0; i < STEPS2; i++) {\n                index.push(((STEPS2 * j) + (1 + i) % STEPS2) % points.length); // 2\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2) % points.length); // 1\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2) % points.length); // 3\n\n                index.push(((STEPS2 * j) + STEPS2 + (0 + i) % STEPS2) % points.length); // 4\n                index.push(((STEPS2 * j) + STEPS2 + (1 + i) % STEPS2) % points.length); // 3\n                index.push(((STEPS2 * j) + (0 + i) % STEPS2) % points.length); // 5\n            }\n        }\n\n        this.buildMesh(points, index, inverse);\n    }\n\n    private torusFunction3(alpha: number): Vector4f {\n        const p = 2\n        const q = 3;\n        const r = 0.5 * (2 + Math.sin(q * alpha));\n        return new Vector4f(r * Math.cos(p * alpha),\n            r * Math.cos(q * alpha),\n            r * Math.sin(p * alpha)).mul(70);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Fog {\n\n    public abstract computeVertexColor(color: Vector4f, vertex: Vector4f): Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Fog } from './Fog';\n\nexport class LinearFog extends Fog {\n\n    private zStart: number;\n    private zEnd: number;\n    private fogColor: Vector4f;\n\n    public constructor(zStart: number, zEnd: number, fogColor: Vector4f) {\n        super();\n        this.zStart = zStart;\n        this.zEnd = zEnd;\n        this.fogColor = fogColor;\n    }\n\n    public computeVertexColor(color: Vector4f, vertex: Vector4f): Vector4f {\n        if (vertex.z >= this.zStart) {\n            return color;\n        } else if (vertex.z <= this.zEnd) {\n            return this.fogColor;\n        } else {\n            const f: number = (this.zEnd - vertex.z) / (this.zEnd - this.zStart);\n            return new Vector4f(\n                color.x * f + this.fogColor.x * (1 - f),\n                color.y * f + this.fogColor.y * (1 - f),\n                color.z * f + this.fogColor.z * (1 - f)\n            );\n        }\n    }\n\n}\n","import { CullFace } from '../../CullFace';\nimport { Framebuffer } from '../../Framebuffer';\nimport { TorusKnot } from '../../geometrical-objects/TorusKnot';\nimport { Matrix4f } from '../../math/Matrix4f';\nimport { Vector4f } from '../../math/Vector4f';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Fog } from '../../shading/fog/Fog';\nimport { LinearFog } from '../../shading/fog/LinearFog';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\nimport RandomNumberGenerator from '../../RandomNumberGenerator';\nimport { GouraudShadingRenderingPipeline } from '../../rendering-pipelines/GouraudShadingRenderingPipeline';\n\nexport class TorusKnotTunnelScene extends AbstractScene {\n\n    private noise: Texture;\n    private particleTexture: Texture;\n    private cocoon: Texture;\n    private torusKnot: TorusKnot = new TorusKnot(true);\n    private fog: Fog = new LinearFog(-50, -240, new Vector4f(0.67, 0.4, 0.5, 1.0));\n    private renderingPipeline: GouraudShadingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.renderingPipeline = new GouraudShadingRenderingPipeline(framebuffer);\n        this.renderingPipeline.setCullFace(CullFace.FRONT);\n        this.renderingPipeline.setFog(this.fog);\n\n        return Promise.all([\n            TextureUtils.generateProceduralNoise().then((texture: Texture) => this.noise = texture),\n            TextureUtils.load(require('../../assets/cocoon.png'), false).then(\n                (texture: Texture) => this.cocoon = texture\n            ),\n            TextureUtils.generateProceduralParticleTexture2().then(\n                (texture: Texture) => this.particleTexture = texture\n            ),\n        ]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.renderingPipeline.setCullFace(CullFace.FRONT);\n        this.torusTunnel(framebuffer, time * 0.019);\n        framebuffer.drawScaledTextureClipAdd(\n            framebuffer.width / 2 - this.cocoon.width / 2,\n            framebuffer.height / 2 - this.cocoon.height / 2,\n            this.cocoon.width, this.cocoon.height, this.cocoon, 0.67);\n\n        // framebuffer.noise(time, this.noise);\n        this.glitchScreen(framebuffer, time * 5, this.noise);\n    }\n\n    public glitchScreen(framebuffer: Framebuffer, elapsedTime: number, texture: Texture, noise: boolean = true): void {\n\n        const glitchFactor = (Math.sin(elapsedTime * 0.00002) * 0.9 + 0.1);\n        const rng = new RandomNumberGenerator();\n        rng.setSeed((elapsedTime / 250) | 0);\n        const texture2 = new Texture();\n        texture2.height = framebuffer.height;\n        texture2.width = framebuffer.width;\n        texture2.texture = framebuffer.framebuffer;\n\n\n        const blockWidth = 20;\n        const horizontalUnits = Math.floor(framebuffer.width / blockWidth);\n        const verticalUnits = Math.floor(framebuffer.height / blockWidth);\n\n        for (let x = 0; x < horizontalUnits; x++) {\n            for (let y = 0; y < verticalUnits; y++) {\n                if (rng.getFloat() > 0.25) {\n                    continue;\n                }\n\n                framebuffer.drawTextureRect(blockWidth * (horizontalUnits - x), blockWidth * ((horizontalUnits * rng.getFloat()) | 0), blockWidth * x, blockWidth * y, blockWidth, blockWidth, texture2.texture, texture2.width, 0.03 + 0.35 * glitchFactor);\n            }\n        }\n\n        if (noise) {\n            for (let x = 0; x < horizontalUnits; x++) {\n                for (let y = 0; y < verticalUnits; y++) {\n                    framebuffer.drawTextureRect(x * blockWidth, y * blockWidth, blockWidth * (Math.round(elapsedTime / 100 + x + y) % 12), 0, blockWidth, blockWidth, texture.texture, texture.width, 0.1 + 0.3 * glitchFactor);\n                }\n            }\n        }\n\n        framebuffer.fastFramebufferCopy(framebuffer.tmpGlitch, framebuffer.framebuffer);\n\n        // now distort the tmpGlitch buffer and render to framebuffer again\n\n        const rng2 = new RandomNumberGenerator();\n\n        for (let k = 0; k < 8; k++) {\n            let yStart = Math.round(rng.getFloat() * 180);\n            const size = 3 + Math.round(rng.getFloat() * 20);\n            rng2.setSeed((elapsedTime / 250) | 0);\n            const scale = rng2.getFloat() * glitchFactor;\n            const off = rng.getFloat() * glitchFactor;\n            for (let y = 0; y < size; y++) {\n                const offset = Math.abs(Math.round(off * 25) + Math.round(rng2.getFloat() * 3)\n                    + Math.round(Math.cos(y * 0.01 + elapsedTime * 0.002 + off) * scale * 5));\n\n                let index = yStart * framebuffer.width;\n                let glIndex = yStart * framebuffer.width + framebuffer.width - offset;\n\n                for (let i = 0; i < Math.max(0, offset); i++) {\n                    framebuffer.framebuffer[index++] = framebuffer.tmpGlitch[glIndex++];\n                }\n\n                glIndex = yStart * framebuffer.width;\n                const count = framebuffer.width - offset;\n\n                for (let i = 0; i < count; i++) {\n                    framebuffer.framebuffer[index++] = framebuffer.tmpGlitch[glIndex++];\n                }\n                yStart++;\n            }\n        }\n    }\n\n    public torusTunnel(framebuffer: Framebuffer, elapsedTime: number): void {\n        framebuffer.clearDepthBuffer();\n\n        const scale = 1.0;\n        const lookAhead: number = 0.4;\n\n        const frame = this.torusFunction3(elapsedTime * 0.02);\n        const frame2 = this.torusFunction3(elapsedTime * 0.02 + lookAhead);\n\n        const tangent = frame2.sub(frame).normalize();\n        let up = frame.add(frame2).normalize();\n        const right = tangent.cross(up).normalize();\n        up = right.cross(tangent).normalize();\n\n        const translation = Matrix4f.constructIdentityMatrix();\n        // translation vector\n        translation.m14 = -frame.x;\n        translation.m24 = -frame.y;\n        translation.m34 = -frame.z;\n\n        const rotation = Matrix4f.constructIdentityMatrix();\n        // x vector\n        rotation.m11 = right.x;\n        rotation.m21 = right.y;\n        rotation.m31 = right.z;\n\n        // y vector\n        rotation.m12 = up.x;\n        rotation.m22 = up.y;\n        rotation.m32 = up.z;\n\n        // z vector\n        rotation.m13 = -tangent.x;\n        rotation.m23 = -tangent.y;\n        rotation.m33 = -tangent.z;\n\n        const finalMatrix = rotation.transpose().multiplyMatrix(translation);\n\n        let modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale).multiplyMatrix(Matrix4f.constructYRotationMatrix(elapsedTime * 0.035));\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(0, 0, -10).multiplyMatrix(modelViewMartrix.multiplyMatrix(Matrix4f.constructXRotationMatrix(elapsedTime * 0.04)));\n        modelViewMartrix = Matrix4f.constructZRotationMatrix(elapsedTime * 0.01).multiplyMatrix(finalMatrix);\n\n        this.renderingPipeline.draw(framebuffer, this.torusKnot.getMesh(), modelViewMartrix);\n    }\n\n    private torusFunction3(alpha: number): Vector4f {\n        const p = 2;\n        const q = 3;\n        const r = 0.5 * (2 + Math.sin(q * alpha));\n        return new Vector4f(r * Math.cos(p * alpha),\n            r * Math.cos(q * alpha),\n            r * Math.sin(p * alpha)).mul(70);\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { TorusKnotTunnelScene } from '../../torus-knot-tunnel/TorusKnotTunnelScene';\n\nexport class Scene13 {\n    private TorusKnotTunnelScene: TorusKnotTunnelScene;\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.TorusKnotTunnelScene = new TorusKnotTunnelScene();\n\n        return Promise.all([\n            this.TorusKnotTunnelScene.init(framebuffer),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        this.TorusKnotTunnelScene.render(framebuffer, time);\n    }\n\n}","import { Color } from '../core/Color';\n\nexport class ColorInterpolator {\n\n    public startColor: Color = new Color();\n    public colorSlope: Color = new Color();\n\n    public setup(c1: Color, c2: Color, distance: number): void {\n        this.colorSlope.r = (c2.r - c1.r) / distance;\n        this.colorSlope.g = (c2.g - c1.g) / distance;\n        this.colorSlope.b = (c2.b - c1.b) / distance;\n\n        this.startColor.r = c1.r;\n        this.startColor.g = c1.g;\n        this.startColor.b = c1.b;\n    }\n\n    public advance(): void {\n        this.startColor.r += this.colorSlope.r;\n        this.startColor.g += this.colorSlope.g;\n        this.startColor.b += this.colorSlope.b;\n    }\n\n}\n","import { Framebuffer } from '../Framebuffer';\nimport { Vertex } from '../Vertex';\nimport { AbstractScannlineTriangleRasterizer } from './AbstractScanlineTriangleRasterizer';\nimport { ColorInterpolator } from './ColorInterpolator';\nimport { SlopeInterpolator } from './SlopeInterpolator';\n\nexport class GouraudShadingTriangleRasterizer extends AbstractScannlineTriangleRasterizer {\n\n\n    private colorInterpolator1: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator2: ColorInterpolator = new ColorInterpolator();\n    private colorInterpolator3: ColorInterpolator = new ColorInterpolator();\n    private rowColorInterpolator: ColorInterpolator = new ColorInterpolator();\n    private leftSlope: SlopeInterpolator = new SlopeInterpolator();\n    private rightSlope: SlopeInterpolator = new SlopeInterpolator();\n\n    constructor(private framebuffer: Framebuffer) {\n        super();\n    }\n\n    protected fillLongRightTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v2);\n        this.rightSlope.setup(v1, v3);\n        this.colorInterpolator1.setup(v1.color, v2.color, this.leftSlope.yDistance);\n        this.colorInterpolator2.setup(v1.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator1, this.colorInterpolator2, this.leftSlope, this.rightSlope);\n\n        this.leftSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.leftSlope, this.colorInterpolator3, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n    }\n\n    protected fillLongLeftTriangle(framebuffer: Framebuffer, v1: Vertex, v2: Vertex, v3: Vertex): void {\n        this.leftSlope.setup(v1, v3);\n        this.rightSlope.setup(v1, v2);\n        this.colorInterpolator2.setup(v1.color, v2.color, this.rightSlope.yDistance);\n        this.colorInterpolator1.setup(v1.color, v3.color, this.leftSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator2,this.leftSlope, this.rightSlope);\n\n        this.rightSlope.setup(v2, v3);\n        this.colorInterpolator3.setup(v2.color, v3.color, this.rightSlope.yDistance);\n        this.drawSpan(framebuffer, this.rightSlope, this.colorInterpolator1, this.colorInterpolator3,this.leftSlope, this.rightSlope);\n    }\n\n    drawSpan(framebuffer: Framebuffer, shortSlope: SlopeInterpolator, colorInterpolator1: ColorInterpolator, colorInterpolator2: ColorInterpolator,\n        leftSlope: SlopeInterpolator, rightSlope: SlopeInterpolator) {\n        \n        let yPosition = shortSlope.yStart;\n        for (let i = 0; i < shortSlope.yDistance; i++) {\n            const length = Math.round(rightSlope.currentX) - Math.round(leftSlope.currentX);\n            this.rowColorInterpolator.setup(colorInterpolator1.startColor, colorInterpolator2.startColor, length);\n            let framebufferIndex = Math.round(yPosition) * framebuffer.width + Math.round(leftSlope.currentX);\n            const spanzStep = (rightSlope.currentZ - leftSlope.currentZ) / length;\n            let wStart = leftSlope.currentZ;\n            for (let j = 0; j < length; j++) {\n                if (wStart < framebuffer.wBuffer[framebufferIndex]) {\n                    framebuffer.wBuffer[framebufferIndex] = wStart;\n                    framebuffer.framebuffer[framebufferIndex] = this.rowColorInterpolator.startColor.toPackedFormat();\n                }\n                framebufferIndex++;\n                wStart += spanzStep;\n                this.rowColorInterpolator.advance();\n            }\n\n            leftSlope.advance()\n            rightSlope.advance();\n           \n            colorInterpolator1.advance();\n            colorInterpolator2.advance();\n\n            yPosition++;\n        }\n    }\n\n}\n","import { Vertex } from '../Vertex';\n\nexport class SlopeInterpolator {\n\n    yDistance: number;\n    slope: number;\n    zslope: number;\n    currentZ: number;\n    currentX: number;\n    yStart: number;\n\n    setup(top: Vertex, bottom: Vertex) {\n        this.yDistance = bottom.projection.y - top.projection.y;\n        this.slope = (bottom.projection.x - top.projection.x) / this.yDistance;\n        this.zslope = (1 / bottom.projection.z - 1 / top.projection.z) / this.yDistance;\n        this.currentZ = 1.0 / top.projection.z;\n        this.currentX = top.projection.x;\n        this.yStart = top.projection.y;\n    }\n\n    advance() {\n        this.currentX += this.slope;\n        this.currentZ += this.zslope;\n    }\n}\n","import { Color } from '../core/Color';\nimport { Framebuffer } from '../Framebuffer';\nimport { FlatshadedMesh } from '../geometrical-objects/FlatshadedMesh';\nimport { Vector4f } from '../math/index';\nimport { Matrix4f } from '../math/Matrix4f';\nimport { SutherlandHodgman2DClipper } from '../screen-space-clipping/SutherlandHodgman2DClipper';\nimport { Fog } from '../shading/fog/Fog';\nimport { PhongLighting } from '../shading/illumination-models/PhongLighting';\nimport { PointLight } from '../shading/light/PointLight';\nimport { Material } from '../shading/material/Material';\nimport { Vertex } from '../Vertex';\nimport { AbstractRenderingPipeline } from './AbstractRenderingPipeline';\nimport { AbstractTriangleRasterizer } from '../rasterizer/AbstractTriangleRasterizer';\nimport { GouraudShadingTriangleRasterizer } from '../rasterizer/GouraudShadingTriangleRasterizer';\n\n/**\n * TODO:\n * - object with position, rotation, material, color\n * - remove tempp matrix objects: instead store one global MV  matrix and manipulate\n *   it directly without generating temp amtrices every frame\n * - no lighting for culled triangles\n * - only z clip if necessary (no clip, fully visible)\n * Optimization:\n * - no shading / only texture mapping (use function pointers to set correct rasterization function)\n * - use delta step method from black art of 3d programming\n * - generate object only once\n * - dont use temp arrays / instead use always the same array preallocated\n */\nexport class GouraudShadingRenderingPipeline extends AbstractRenderingPipeline {\n\n    private fog: Fog = null;\n    private lights: Array<PointLight> = null;\n    private material: Material = null;\n    private lighting: boolean = true;\n    private color: Color = Color.WHITE;\n\n    // it is possible to change the rasterizer here for\n    // flat, gouroud, texture mapping etc.. should be done with clipper as well!\n    private triangleRasterizer: AbstractTriangleRasterizer = null;\n    private clipper: SutherlandHodgman2DClipper;\n\n    private projectedVertices: Array<Vector4f> = new Array<Vector4f>(\n        new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1), new Vector4f(0, 0, 0, 1)\n    );\n\n    private vertexArray: Array<Vertex> = new Array<Vertex>(\n        new Vertex(), new Vertex(), new Vertex()\n    );\n\n    public constructor(framebuffer: Framebuffer) {\n        super(framebuffer);\n        this.clipper = new SutherlandHodgman2DClipper(framebuffer);\n\n        const light1: PointLight = new PointLight();\n        light1.ambientIntensity = new Vector4f(1, 1, 1, 1);\n        light1.diffuseIntensity = new Vector4f(1, 1, 1, 1);\n        light1.specularIntensity = new Vector4f(1, 1, 1, 1);\n        light1.position = new Vector4f(3, 0, -2, 1);\n\n        const light2: PointLight = new PointLight();\n        light2.ambientIntensity = new Vector4f(0, 0, 1, 1);\n        light2.diffuseIntensity = new Vector4f(0, 0.6, 1, 1);\n        light2.specularIntensity = new Vector4f(0.8, 0.8, 0.8, 1);\n        light2.position = new Vector4f(0, -380, -180, 1);\n\n        this.lights = [light1, light2];\n\n        const mat: Material = new Material();\n        mat.ambientColor = new Vector4f(0.12, 0.14, 0.1, 0);\n        mat.diffuseColor = new Vector4f(0.38, 0.4, 0.4, 1);\n        mat.specularColor = new Vector4f(0.8, 0.5, 0.5, 0);\n        mat.shininess = 2;\n\n        this.material = mat;\n        this.triangleRasterizer = new GouraudShadingTriangleRasterizer(framebuffer);\n    }\n\n    public setFramebuffer(framebuffer: Framebuffer) {\n        this.framebuffer = framebuffer;\n    }\n\n    public setFog(fog: Fog): void {\n        this.fog = fog;\n    }\n\n    public setLights(lights: Array<PointLight>): void {\n        this.lights = lights;\n    }\n\n    public enableLighting(enable: boolean): void {\n        this.lighting = enable;\n    }\n\n    public setMaterial(material: Material): void {\n        this.material = material;\n    }\n\n    public setColor(color: Color): void {\n        this.color = color;\n    }\n\n    public drawMeshArray(framebuffer: Framebuffer, meshes: Array<FlatshadedMesh>, modelViewMartrix: Matrix4f): void {\n        for (let j: number = 0; j < meshes.length; j++) {\n            const model: FlatshadedMesh = meshes[j];\n            this.draw(framebuffer, model,modelViewMartrix);\n        }\n    }\n\n\n    public draw(framebuffer: Framebuffer, mesh: FlatshadedMesh, modelViewMartrix: Matrix4f): void {\n\n        const normalMatrix: Matrix4f = modelViewMartrix.computeNormalMatrix();\n\n        for (let i: number = 0; i < mesh.normals.length; i++) {\n            normalMatrix.multiplyHomArr(mesh.normals[i], mesh.transformedNormals[i]);\n        }\n\n        for (let i: number = 0; i < mesh.points.length; i++) {\n            modelViewMartrix.multiplyHomArr(mesh.points[i], mesh.transformedPoints[i]);\n        }\n\n        for (let i: number = 0; i < mesh.faces.length; i++) {\n            const v1: Vector4f = mesh.transformedPoints[mesh.faces[i].v1];\n            const v2: Vector4f = mesh.transformedPoints[mesh.faces[i].v2];\n            const v3: Vector4f = mesh.transformedPoints[mesh.faces[i].v3];\n\n            const normal1: Vector4f = mesh.transformedNormals[mesh.faces[i].n1];\n            const normal2: Vector4f = mesh.transformedNormals[mesh.faces[i].n2];\n            const normal3: Vector4f = mesh.transformedNormals[mesh.faces[i].n3];\n\n            if (this.isInFrontOfNearPlane(v1) &&\n                this.isInFrontOfNearPlane(v2) &&\n                this.isInFrontOfNearPlane(v3)) {\n\n                this.project2(v1, this.projectedVertices[0]);\n                this.project2(v2, this.projectedVertices[1]);\n                this.project2(v3, this.projectedVertices[2]);\n\n                this.vertexArray[0].position = v1;\n                this.vertexArray[0].projection = this.projectedVertices[0];\n                this.vertexArray[0].normal = normal1;\n\n                this.vertexArray[1].position = v2;\n                this.vertexArray[1].projection = this.projectedVertices[1];\n                this.vertexArray[1].normal = normal2;\n\n                this.vertexArray[2].position = v3;\n                this.vertexArray[2].projection = this.projectedVertices[2];\n                this.vertexArray[2].normal = normal3;\n\n                this.renderConvexPolygon(framebuffer, this.vertexArray, true);\n            } else if (!this.isInFrontOfNearPlane(v1) &&\n                !this.isInFrontOfNearPlane(v2) &&\n                !this.isInFrontOfNearPlane(v3)) {\n                continue;\n            } else {\n                this.vertexArray[0].position = v1;\n                this.vertexArray[1].position = v2;\n                this.vertexArray[2].position = v3;\n\n                if (this.lighting) {\n                    this.vertexArray[0].color = this.computeColor(normal1, v1);\n                    this.vertexArray[1].color = this.computeColor(normal2, v2);\n                    this.vertexArray[2].color = this.computeColor(normal3, v3);\n                } else {\n                    this.vertexArray[0].color = this.color;\n                    this.vertexArray[1].color = this.color;\n                    this.vertexArray[2].color = this.color;\n                }\n\n                const output: Array<Vertex> = this.zClipTriangle(this.vertexArray);\n\n                if (output.length < 3) {\n                    return;\n                }\n\n                for (let j: number = 0; j < output.length; j++) {\n                    output[j].projection = this.project(output[j].position);\n                }\n\n                this.renderConvexPolygon(framebuffer, output, false);\n            }\n        }\n    }\n\n    public project(t1: { x: number, y: number, z: number }): Vector4f {\n        return new Vector4f(\n            Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z))),\n            Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z))),\n            t1.z\n        );\n    }\n\n    public project2(t1: { x: number, y: number, z: number }, result: Vector4f): void {\n        result.x = Math.round((this.framebuffer.width / 2) + (292 * t1.x / (-t1.z)));\n        result.y = Math.round((this.framebuffer.height / 2) - (t1.y * 292 / (-t1.z)));\n        result.z = t1.z;\n    }\n\n    public computeNearPlaneIntersection(p1: Vertex, p2: Vertex): Vertex {\n        // TODO: interpolate color linear\n        const ratio: number = (this.NEAR_PLANE_Z - p1.position.z) / (p2.position.z - p1.position.z);\n        const vertex: Vertex = new Vertex();\n        vertex.position = new Vector4f(\n            ratio * (p2.position.x - p1.position.x) + p1.position.x,\n            ratio * (p2.position.y - p1.position.y) + p1.position.y,\n            this.NEAR_PLANE_Z\n        );\n        vertex.color = p2.color.sub(p1.color).mul(ratio).add(p1.color);\n        return vertex;\n    }\n\n    public zClipTriangle(subject: Array<Vertex>): Array<Vertex> {\n        const input: Array<Vertex> = subject;\n        const output: Array<Vertex> = new Array<Vertex>();\n        let S: Vertex = input[input.length - 1];\n\n        for (let i: number = 0; i < input.length; i++) {\n            const point: Vertex = input[i];\n            if (this.isInFrontOfNearPlane(point.position)) {\n                if (!this.isInFrontOfNearPlane(S.position)) {\n                    output.push(this.computeNearPlaneIntersection(S, point));\n                }\n                output.push(point);\n            } else if (this.isInFrontOfNearPlane(S.position)) {\n                output.push(this.computeNearPlaneIntersection(S, point));\n            }\n            S = point;\n        }\n\n        return output;\n    }\n\n    private renderConvexPolygon(framebuffer: Framebuffer, projected: Array<Vertex>, late: boolean = false): void {\n        if (projected.length === 3 &&\n            !this.isTriangleCCW(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection)) {\n            return;\n        }\n\n        if (late) {\n            if (this.lighting) {\n                this.vertexArray[0].color = this.computeColor(this.vertexArray[0].normal, this.vertexArray[0].position);\n                this.vertexArray[1].color = this.computeColor(this.vertexArray[1].normal, this.vertexArray[1].position);\n                this.vertexArray[2].color = this.computeColor(this.vertexArray[2].normal, this.vertexArray[2].position);\n            } else {\n                this.vertexArray[0].color = this.color;\n                this.vertexArray[1].color = this.color;\n                this.vertexArray[2].color = this.color;\n            }\n\n        }\n\n        if (projected.length === 4 &&\n            !this.isTriangleCCW2(\n                projected[0].projection,\n                projected[1].projection,\n                projected[2].projection,\n                projected[3].projection)\n        ) {\n            return;\n        }\n\n        const clippedPolygon: Array<Vertex> = this.clipper.clipConvexPolygon(projected);\n\n        if (clippedPolygon.length < 3) {\n            return;\n        }\n\n        this.triangulateConvexPolygon(framebuffer, clippedPolygon);\n    }\n\n    private triangulateConvexPolygon(framebuffer:Framebuffer, clippedPolygon: Array<Vertex>): void {\n        for (let j: number = 0; j < clippedPolygon.length - 2; j++) {\n            this.triangleRasterizer.drawTriangleDDA(\n                framebuffer,\n                clippedPolygon[0],\n                clippedPolygon[1 + j],\n                clippedPolygon[2 + j]\n            );\n        }\n    }\n\n    private computeColor(normal: Vector4f, vertex: Vector4f): Color {\n\n        // TODO: if lighting is enabled use mat and light\n        // else use Color set\n\n        let vertexColor: Vector4f = new PhongLighting().computeColor(this.material, this.lights, normal, vertex);\n\n        if (this.fog !== null) {\n            vertexColor = this.fog.computeVertexColor(vertexColor, vertex);\n        }\n\n        return new Color(\n            Math.min(255, vertexColor.x * 255),\n            Math.min(255, vertexColor.y * 255),\n            Math.min(255, vertexColor.z * 255),\n            255\n        );\n    }\n\n}\n","\nimport { AbstractClipEdge } from './AbstractClipEdge';\nimport { RightClipEdge } from './RightClipEdge';\nimport { LeftClipEdge } from './LeftClipEdge';\nimport { BottomClipEdge } from './BottomClipEdge';\nimport { TopClipEdge } from './TopClipEdge';\nimport { Vertex } from '../Vertex';\nimport { Framebuffer } from '../Framebuffer';\n\nexport class SutherlandHodgman2DClipper {\n\n\n    private clipRegion: Array<AbstractClipEdge>;\n\n    constructor(private framebuffer: Framebuffer) {\n        this.clipRegion = new Array<AbstractClipEdge>(\n            new RightClipEdge(framebuffer),\n            new LeftClipEdge(framebuffer),\n            new BottomClipEdge(framebuffer),\n            new TopClipEdge(framebuffer)\n        );\n\n    }\n\n    /**\n     * FIXME: optimize by minimizing creation of new arrays\n     *\n     * @param {Array<Vertex>} subject\n     * @return {Array<Vertex>}\n     */\n    public clipConvexPolygon(subject: Array<Vertex>): Array<Vertex> {\n\n        let output = subject;\n\n        for (let j = 0; j < this.clipRegion.length; j++) {\n            const edge: AbstractClipEdge = this.clipRegion[j];\n            const input = output;\n            output = new Array<Vertex>();\n            let S = input[input.length - 1];\n\n            for (let i = 0; i < input.length; i++) {\n                const point = input[i];\n                if (edge.isInside(point)) {\n                    if (!edge.isInside(S)) {\n                        output.push(edge.computeIntersection(S, point));\n                    }\n                    output.push(point);\n                } else if (edge.isInside(S)) {\n                    output.push(edge.computeIntersection(S, point));\n                }\n                S = point;\n            }\n        }\n\n        return output;\n    }\n\n}\n","import { Vector4f } from '../../math/index';\nimport { PointLight } from '../light/PointLight';\nimport { Material } from '../material/Material';\n\nexport class PhongLighting {\n\n    public computeColor(mat: Material, lights: Array<PointLight>, normal: Vector4f, vertex: Vector4f): Vector4f {\n        let finalColor: Vector4f = new Vector4f(0, 0, 0);\n\n        for (let x: number = 0; x < lights.length; x++) {\n            const light: PointLight = lights[x];\n            const ambientIntensity: Vector4f = this.computeAmbientIntensity(mat, light);\n            const diffuseIntensity: Vector4f = this.computeDiffuseIntensity(mat, light, normal, vertex);\n            const specularIntensity: Vector4f = this.computeSpecularIntensity(mat, light, normal, vertex);\n\n            finalColor = finalColor.add(ambientIntensity)\n                .add(diffuseIntensity)\n                .add(specularIntensity);\n        }\n\n        return finalColor;\n    }\n\n    private computeAmbientIntensity(mat: Material, l: PointLight): Vector4f {\n        return mat.ambientColor.componentWiseMul(l.ambientIntensity);\n    }\n\n    private computeDiffuseIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const scale: number = Math.min(Math.max(normal.dot(lightDirection), 0), 1.0);\n        return mat.diffuseColor.componentWiseMul(l.diffuseIntensity).mul(scale);\n    }\n\n    private computeSpecularIntensity(mat: Material, l: PointLight, normal: Vector4f, vertex: Vector4f): Vector4f {\n        const lightDirection: Vector4f = l.position.sub(vertex).normalize();\n        const r: Vector4f = normal.mul(normal.dot(lightDirection) * 2.0).sub(lightDirection);\n        const v: Vector4f = vertex.mul(-1).normalize();\n        const scale: number = Math.pow(Math.max(r.dot(v), 0), mat.shininess);\n        return mat.specularColor.componentWiseMul(l.specularIntensity).mul(scale);\n    }\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport abstract class Light {\n\n    public ambientIntensity: Vector4f;\n    public diffuseIntensity: Vector4f;\n    public specularIntensity: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\nimport { Light } from './Light';\n\nexport class PointLight extends Light {\n\n    public position: Vector4f;\n\n}\n","import { Vector4f } from '../../math/index';\n\nexport class Material {\n\n    public ambientColor: Vector4f;\n    public diffuseColor: Vector4f;\n    public specularColor: Vector4f;\n    public emissiveColor: Vector4f;\n\n    public shininess: number;\n\n}\n"],"names":["TorusKnot","AbstractGeometricObject","inverse","super","points","i","frame","this","torusFunction3","Math","PI","frame2","tangent","sub","up","add","normalize","right","cross","mul","r","pos","sin","cos","push","index","j","length","buildMesh","alpha","Vector4f","Fog","LinearFog","zStart","zEnd","fogColor","computeVertexColor","color","vertex","z","f","x","y","TorusKnotTunnelScene","AbstractScene","noise","particleTexture","cocoon","torusKnot","fog","renderingPipeline","init","framebuffer","GouraudShadingRenderingPipeline","setCullFace","CullFace","FRONT","setFog","Promise","all","TextureUtils","generateProceduralNoise","then","texture","load","generateProceduralParticleTexture2","render","time","torusTunnel","drawScaledTextureClipAdd","width","height","glitchScreen","elapsedTime","glitchFactor","rng","RandomNumberGenerator","setSeed","texture2","Texture","blockWidth","horizontalUnits","floor","verticalUnits","getFloat","drawTextureRect","round","fastFramebufferCopy","tmpGlitch","rng2","k","yStart","size","scale","off","offset","abs","glIndex","max","count","clearDepthBuffer","translation","Matrix4f","constructIdentityMatrix","m14","m24","m34","rotation","m11","m21","m31","m12","m22","m32","m13","m23","m33","finalMatrix","transpose","multiplyMatrix","modelViewMartrix","constructScaleMatrix","constructYRotationMatrix","constructTranslationMatrix","constructXRotationMatrix","constructZRotationMatrix","draw","getMesh","Scene13","ColorInterpolator","startColor","colorSlope","setup","c1","c2","distance","g","b","advance","GouraudShadingTriangleRasterizer","colorInterpolator1","colorInterpolator2","colorInterpolator3","rowColorInterpolator","leftSlope","rightSlope","constructor","fillLongRightTriangle","v1","v2","v3","yDistance","drawSpan","fillLongLeftTriangle","shortSlope","yPosition","currentX","framebufferIndex","spanzStep","currentZ","wStart","wBuffer","toPackedFormat","SlopeInterpolator","slope","zslope","top","bottom","projection","lights","material","lighting","WHITE","triangleRasterizer","clipper","projectedVertices","Array","vertexArray","light1","ambientIntensity","diffuseIntensity","specularIntensity","position","light2","mat","ambientColor","diffuseColor","specularColor","shininess","setFramebuffer","setLights","enableLighting","enable","setMaterial","setColor","drawMeshArray","meshes","model","mesh","normalMatrix","computeNormalMatrix","normals","multiplyHomArr","transformedNormals","transformedPoints","faces","normal1","n1","normal2","n2","normal3","n3","isInFrontOfNearPlane","project2","normal","renderConvexPolygon","computeColor","output","zClipTriangle","project","t1","result","computeNearPlaneIntersection","p1","p2","ratio","NEAR_PLANE_Z","subject","input","S","point","projected","late","isTriangleCCW","isTriangleCCW2","clippedPolygon","clipConvexPolygon","triangulateConvexPolygon","drawTriangleDDA","vertexColor","min","SutherlandHodgman2DClipper","clipRegion","edge","isInside","computeIntersection","PhongLighting","finalColor","light","computeAmbientIntensity","computeDiffuseIntensity","computeSpecularIntensity","l","componentWiseMul","lightDirection","dot","v","pow","Light","PointLight","Material","emissiveColor"],"sourceRoot":""}