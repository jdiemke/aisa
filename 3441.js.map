{"version":3,"file":"3441.js","mappings":"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","sources":["webpack://aisa/./src/examples/distorted-sphere/DistortedSphereScene.ts","webpack://aisa/./src/examples/demo/parts/Scene6.ts","webpack://aisa/./src/examples/plane-deformation/PlaneDeformationScene.ts"],"sourcesContent":["import { Framebuffer } from '../../Framebuffer';\nimport { Matrix4f, Vector4f } from '../../math';\nimport { AbstractScene } from '../../scenes/AbstractScene';\nimport { Texture } from '../../texture/Texture';\nimport { TextureUtils } from '../../texture/TextureUtils';\nimport { Vertex } from '../../Vertex';\nimport { TextureCoordinate } from '../../TextureCoordinate';\nimport { Color } from '../../core/Color';\nimport { CullFace } from '../../CullFace';\nimport { TexturingRenderingPipeline } from '../../rendering-pipelines/TexturingRenderingPipeline';\n\ninterface IndexMesh {\n    points: Array<Vector4f>,\n    points2: Array<Vector4f>,\n    normals: Array<Vector4f>,\n    normals2: Array<Vector4f>,\n    index: Array<number>\n}\n\nexport class DistortedSphereScene extends AbstractScene {\n\n    private heightmapSphere: Texture;\n\n    private env: Texture;\n    private obj: IndexMesh;\n    private texturedRenderingPipeline: TexturingRenderingPipeline;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        this.texturedRenderingPipeline = new TexturingRenderingPipeline(framebuffer);\n        return Promise.all([\n            TextureUtils.load(require('../../assets/heightmapSphere.png'), false).then(\n                texture => this.heightmapSphere = texture\n            ),\n            TextureUtils.load(require('../../assets/envmap.png'), false).then(\n                texture => this.env = texture\n            ),\n        ]).then(\n            () => {\n                this.obj = this.createSphereDistplaced(this.heightmapSphere);\n            });\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        framebuffer.clearColorBuffer(Color.BLACK.toPackedFormat());\n        this.renderTransparent(framebuffer, time);\n    }\n\n    public renderTransparent(framebuffer: Framebuffer, time: number): void {\n        framebuffer.setCullFace(CullFace.BACK);\n        framebuffer.setTexture(this.env);\n        const scale: number = 3.7;\n\n        let modelViewMartrix = Matrix4f.constructScaleMatrix(scale, scale, scale)\n            .multiplyMatrix(Matrix4f.constructYRotationMatrix(time * 0.0001)\n                .multiplyMatrix(Matrix4f.constructXRotationMatrix(time * 0.0001)));\n\n        modelViewMartrix = Matrix4f.constructTranslationMatrix(-0, -0,\n            -10 - (Math.sin(time * 0.0006) * 0.5 + 0.5) * 6)\n            .multiplyMatrix(modelViewMartrix);\n        framebuffer.clearDepthBuffer();\n        this.shadingSphereEnvDisp2(framebuffer, time * 0.0004, modelViewMartrix);\n    }\n\n    public createSphere() {\n\n        const pointsA: Array<Vector4f> = [\n            new Vector4f(0.0, -1.0, 0.0),\n            new Vector4f(1.0, 0.0, 0.0),\n            new Vector4f(0.0, 0.0, 1.0),\n            new Vector4f(-1.0, 0.0, 0.0),\n            new Vector4f(0.0, 0.0, -1.0),\n            new Vector4f(0.0, 1.0, 0.0)\n        ];\n\n        const indexA: Array<number> = [\n            0, 1, 2,\n            0, 2, 3,\n            0, 3, 4,\n            0, 4, 1,\n            1, 5, 2,\n            2, 5, 3,\n            3, 5, 4,\n            4, 5, 1\n        ];\n\n        const k = this.divideSphere(pointsA, indexA, 4);\n\n        // optimize\n        const points: Array<Vector4f> = [];\n        const points2: Array<Vector4f> = [];\n        const normals: Array<Vector4f> = [];\n        const normals2: Array<Vector4f> = [];\n\n        const index: Array<number> = [];\n\n        k.index.forEach(i => {\n            const p = k.points[i];\n\n            const point = points.find(findPoint => findPoint.sub(p).length() < 0.001);\n\n            if (point) {\n                const idx = points.indexOf(point);\n                index.push(idx);\n            } else {\n                index.push(points.push(p) - 1);\n            }\n        });\n\n        points.forEach(() => {\n            normals.push(new Vector4f(0, 0, 0));\n            normals2.push(new Vector4f(0, 0, 0));\n            points2.push(new Vector4f(0, 0, 0));\n        })\n\n        return {\n            points,\n            points2,\n            normals,\n            normals2,\n            index\n        }\n    }\n\n    public divideSphere(points: Array<Vector4f>, index: Array<number>, steps: number) {\n\n        const points2: Array<Vector4f> = [];\n        const normals2: Array<Vector4f> = [];\n        const index2: Array<number> = [];\n\n        let c = 0;\n        for (let i = 0; i < index.length; i += 3) {\n            const v1 = points[index[i]];\n            const v2 = points[index[i + 1]];\n            const v3 = points[index[i + 2]];\n\n            const vn1 = v2.sub(v1).mul(0.5).add(v1).normalize();\n            const vn2 = v3.sub(v2).mul(0.5).add(v2).normalize();\n            const vn3 = v1.sub(v3).mul(0.5).add(v3).normalize();\n\n            points2.push(v1); points2.push(vn1); points2.push(vn3);\n            normals2.push(v1); normals2.push(vn1); normals2.push(vn3);\n            index2.push(c++); index2.push(c++); index2.push(c++);\n\n            points2.push(vn1); points2.push(v2); points2.push(vn2);\n            normals2.push(vn1); normals2.push(v2); normals2.push(vn2);\n            index2.push(c++); index2.push(c++); index2.push(c++);\n\n            points2.push(vn1); points2.push(vn2); points2.push(vn3);\n            normals2.push(vn1); normals2.push(vn2); normals2.push(vn3);\n            index2.push(c++); index2.push(c++); index2.push(c++);\n\n            points2.push(vn3); points2.push(vn2); points2.push(v3);\n            normals2.push(vn3); normals2.push(vn2); normals2.push(v3);\n            index2.push(c++); index2.push(c++); index2.push(c++);\n        }\n\n        if (steps > 0) {\n            return this.divideSphere(points2, index2, --steps);\n        } else {\n            return {\n                points: points2,\n                normals: normals2,\n                index: index2\n            }\n        }\n    }\n\n\n    public createSphereDistplaced(texture: Texture) {\n        const sphere: {\n            points: Array<Vector4f>,\n            points2: Array<Vector4f>,\n            normals: Array<Vector4f>,\n            normals2: Array<Vector4f>,\n            index: Array<number>\n        } = this.createSphere();\n        const newPoints: Array<Vector4f> = new Array<Vector4f>();\n        sphere.points.forEach((point) => {\n            const x = point.x;\n            const y = point.y;\n            const z = point.z;\n            const u = Math.floor((0.5 + Math.atan2(z, x) / (2 * Math.PI)) * 255);\n            const v = Math.floor((0.5 - Math.asin(y) / Math.PI) * 255);\n            const disp = 1 + 1.4 * ((texture.texture[u + v * 256] & 0xff) / 255);\n            newPoints.push(point.mul(disp));\n        });\n        sphere.points = newPoints;\n        return sphere;\n    }\n\n    public shadingSphereEnvDisp2(framebuffer: Framebuffer, elapsedTime: number, modelViewMartrix: Matrix4f): void {\n        const result = this.obj;\n\n\n        for (let i = 0; i < result.points.length; i++) {\n            const y = result.points[i].z;\n            const x = result.points[i].x;\n            const length = Math.sqrt(x * x + y * y);\n            let rot = Math.sin(result.points[i].y * 0.539 + Math.max(20 - length * 2, 0) * 0.06 + elapsedTime * 0.9) * 4.5;\n            rot *= Math.sin(elapsedTime * 0.25) * 0.5 + 0.5;\n            result.points2[i].y = result.points[i].y;\n            result.points2[i].x = result.points[i].x * Math.cos(rot) - result.points[i].z * Math.sin(rot);\n            result.points2[i].z = result.points[i].x * Math.sin(rot) + result.points[i].z * Math.cos(rot);\n\n            result.normals[i].x = 0;\n            result.normals[i].y = 0;\n            result.normals[i].z = 0;\n        }\n\n        const points = result.points2;\n        const index = result.index;\n        const normals = result.normals;\n\n        const norm: Vector4f = new Vector4f(0, 0, 0);\n        const norm2: Vector4f = new Vector4f(0, 0, 0);\n        const cross: Vector4f = new Vector4f(0, 0, 0);\n        for (let i = 0; i < index.length; i += 3) {\n            const v1: Vector4f = points[index[i]];\n            const v2: Vector4f = points[index[i + 1]];\n            const v3: Vector4f = points[index[i + 2]];\n\n\n            norm.sub2(v2, v1);\n            norm2.sub2(v3, v1);\n            cross.cross2(norm, norm2);\n            const normal = cross;\n            normals[index[i]].add2(normals[index[i]], normal);\n            normals[index[i + 1]].add2(normals[index[i + 1]], normal);\n            normals[index[i + 2]].add2(normals[index[i + 2]], normal);\n        }\n\n        for (let i = 0; i < normals.length; i++) {\n            normals[i].normalize2();\n        }\n\n        const points2: Array<Vector4f> = result.points2;\n        const normals2: Array<Vector4f> = result.normals2;\n\n        const normalMatrix = modelViewMartrix.computeNormalMatrix();\n\n        for (let n = 0; n < normals.length; n++) {\n            normalMatrix.multiplyHomArr(normals[n], normals2[n]);\n        }\n\n        for (let p = 0; p < points.length; p++) {\n            const transformed = modelViewMartrix.multiplyHom(points[p]);\n\n            points2[p].x = Math.round((framebuffer.width * 0.5) + (transformed.x / (-transformed.z * 0.0078)));\n            points2[p].y = Math.round((framebuffer.height * 0.5) - (transformed.y / (-transformed.z * 0.0078)));\n            points2[p].z = transformed.z;\n        }\n\n        const vertex1 = new Vertex();\n        vertex1.textureCoordinate = new TextureCoordinate();\n        const vertex2 = new Vertex();\n        vertex2.textureCoordinate = new TextureCoordinate();\n        const vertex3 = new Vertex();\n        vertex3.textureCoordinate = new TextureCoordinate();\n        const vertexArray = new Array<Vertex>(vertex1, vertex2, vertex3);\n        for (let i = 0; i < index.length; i += 3) {\n\n            const v1 = points2[index[i]];\n            const n1 = normals2[index[i]];\n\n            const v2 = points2[index[i + 1]];\n            const n2 = normals2[index[i + 1]];\n\n            const v3 = points2[index[i + 2]];\n            const n3 = normals2[index[i + 2]];\n\n            if (framebuffer.isTriangleCCW(v1, v2, v3)) {\n\n                vertexArray[0].projection = v1;\n                framebuffer.fakeSphere(n1, vertex1);\n\n                vertexArray[1].projection = v2;\n                framebuffer.fakeSphere(n2, vertex2);\n\n                vertexArray[2].projection = v3;\n                framebuffer.fakeSphere(n3, vertex3);\n\n                if (v1.x < framebuffer.minWindow.x ||\n                    v2.x < framebuffer.minWindow.x ||\n                    v3.x < framebuffer.minWindow.x ||\n                    v1.x > framebuffer.maxWindow.x ||\n                    v2.x > framebuffer.maxWindow.x ||\n                    v3.x > framebuffer.maxWindow.x ||\n                    v1.y < framebuffer.minWindow.y ||\n                    v2.y < framebuffer.minWindow.y ||\n                    v3.y < framebuffer.minWindow.y ||\n                    v1.y > framebuffer.maxWindow.y ||\n                    v2.y > framebuffer.maxWindow.y ||\n                    v3.y > framebuffer.maxWindow.y) {\n\n\n                    this.texturedRenderingPipeline.clipConvexPolygon(framebuffer, vertexArray);\n                } else {\n                    this.texturedRenderingPipeline.triangleRasterizer.drawTriangleDDA(framebuffer, vertexArray[0], vertexArray[1], vertexArray[2]);\n                }\n            }\n        }\n    }\n\n}\n","import { Framebuffer } from '../../../Framebuffer';\nimport { PlaneDeformationScene } from '../../plane-deformation/PlaneDeformationScene';\nimport { DistortedSphereScene } from '../../distorted-sphere/DistortedSphereScene';\nimport { Texture } from '../../../texture/Texture';\nimport { TextureUtils } from '../../../texture/TextureUtils';\n\n/**\n * TODO: extract lens into effect class\n */\nexport class Scene6 {\n    private PlaneDeformationScene: PlaneDeformationScene;\n    private DistortedSphereScene: DistortedSphereScene;\n    private logo: Texture;\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n\n        this.PlaneDeformationScene = new PlaneDeformationScene(3, require('../../../assets/textures/checker.png'));\n        this.DistortedSphereScene = new DistortedSphereScene();\n\n        return Promise.all([\n            this.DistortedSphereScene.init(framebuffer),\n            this.PlaneDeformationScene.init(framebuffer),\n            // https://www.pngitem.com/middle/iwTwxh_face-facial-hair-sitting-tongue-fear-woman-png/\n            TextureUtils.load(require('../../../assets/logos/drug-chick-2.png'), true).then(\n                (texture: Texture) => this.logo = texture\n            ),\n        ])\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n\n        this.PlaneDeformationScene.render(framebuffer, time);\n        this.DistortedSphereScene.renderTransparent(framebuffer, time);\n        framebuffer.drawTexture(0, framebuffer.height - this.logo.height, this.logo, 1.0);\n    }\n\n}","import { Framebuffer } from '../../Framebuffer';\nimport { Texture, TextureUtils } from '../../texture';\nimport { Color } from '../../core/Color';\nimport { Utils } from '../../core/Utils';\n\n/**\n * Plane deformation\n *\n * 2D plane deformations using lookup tables was a great\n * way to get smooth animations of complex calculations\n * running on slower processors. These effects were very\n * common in the 90s demoscene.\n *\n * The idea was to take a texture and deform it using a\n * pre-calculated math reference table. Different formulas\n * gave different effects such as fake 3d tunnels, wormholes\n * and landscapes.\n *\n * https://www.iquilezles.org/www/articles/deform/deform.htm\n *\n */\n\nexport class PlaneDeformationScene {\n\n    private mLUT: Int32Array;\n    public texture: Texture;\n\n    constructor(\n        private effectStyle: number,\n        private texturePath: string\n    ) {\n    }\n\n    onInit() { }\n\n    public init(framebuffer: Framebuffer): Promise<any> {\n        return Promise.all([\n            TextureUtils.load(this.texturePath, false).then(\n                (texture: Texture) => {\n                    this.texture = texture;\n                    this.createLUT(this.effectStyle, framebuffer.width, framebuffer.height, this.texture.width, this.texture.height);\n                }\n            ),\n        ]);\n\n    }\n\n    // fill math lookup table values with crazy values\n    public createLUT(effectStyle: number, effectWidth: number, effectHeight: number, textureWidth: number, textureHeight: number): Promise<any> {\n\n        // initializae lookup array\n        this.mLUT = new Int32Array(3 * effectWidth * effectHeight);\n\n        // increment placeholder\n        let k = 0;\n\n        // u and v are euclidean coordinates\n        let u = 0;\n        let v = 0\n        let bright = 0;\n\n        for (let j = 0; j < effectHeight; j++) {\n            const y = -1.00 + 2.00 * j / effectHeight;\n            for (let i = 0; i < effectWidth; i++) {\n                const x = -1.00 + 2.00 * i / effectWidth;\n                const d = Math.sqrt(x * x + y * y);\n                const a = Math.atan2(y, x);\n\n                const r = d;\n                switch (effectStyle) {\n                    case 1:   // stereographic projection / anamorphosis\n                        u = Math.cos(a) / d;\n                        v = Math.sin(a) / d;\n                        bright = -50 * (2 / (6 * r + 3 * x));\n                        break;\n                    case 2:  // hypnotic rainbow spiral\n                        v = Math.sin(a + Math.cos(3 * r)) / (Math.pow(r, .2));\n                        u = Math.cos(a + Math.cos(3 * r)) / (Math.pow(r, .2));\n                        bright = 1;\n                        break;\n                    case 3:  // rotating tunnel\n                        v = 2 / (6 * r + 3 * x);\n                        u = a * 3 / Math.PI;\n                        bright = 25 * -v;\n                        break;\n                    case 4:  // wavy star-burst\n                        v = (-0.4 / r) + .1 * Math.sin(8 * a);\n                        u = .5 + .5 * a / Math.PI;\n                        bright = 0;\n                        break;\n                    case 5:  // hyper-space travel\n                        u = (0.02 * y + 0.03) * Math.cos(a * 3) / r;\n                        v = (0.02 * y + 0.03) * Math.sin(a * 3) / r;\n                        bright = 0;\n                        break;\n                    case 6:  // five point magnetic flare\n                        u = 1 / (r + 0.5 + 0.5 * Math.sin(5 * a));\n                        v = a * 3 / Math.PI;\n                        bright = 0;\n                        break;\n                    case 7:  // cloud like dream scroll\n                        u = 0.1 * x / (0.11 + r * 0.5);\n                        v = 0.1 * y / (0.11 + r * 0.5);\n                        bright = 0;\n                        break;\n                    case 8:  // floor and ceiling with fade to dark horizon\n                        u = x / Math.abs(y);\n                        v = 1 / Math.abs(y);\n                        bright = 40 * -v;\n                        break;\n                    case 9:  // hot magma liquid swirl\n                        u = 0.5 * (a) / Math.PI;\n                        v = Math.sin(2 * r);\n                        bright = 0;\n                        break;\n                    case 10:  // clockwise flush down the toilet\n                        v = Math.pow(r, 0.1);\n                        u = (1 * a / Math.PI) + r;\n                        bright = 0;\n                        break;\n                    case 11:  // 3D ball\n                        v = x * (3 - Math.sqrt(4 - 5 * r * r)) / (r * r + 1);\n                        u = y * (3 - Math.sqrt(4 - 5 * r * r)) / (r * r + 1);\n                        bright = 7 * -18.7 * (x + y + r * r - (x + y - 1) * Math.sqrt(4 - 5 * r * r) / 3) / (r * r + 1);\n                        break;\n                    default:  // show texture with no deformation or lighting\n                        u = x;\n                        v = y;\n                        bright = 0;\n                        break;\n                }\n                this.mLUT[k++] = (textureWidth * u) & textureWidth - 1;\n                this.mLUT[k++] = (textureHeight * v) & textureHeight - 1;\n                this.mLUT[k++] = Utils.clamp(bright, -255, 255);\n            }\n        }\n        return Promise.all([]);\n    }\n\n    public render(framebuffer: Framebuffer, time: number): void {\n        // this.drawOldPlaneDeformationStar(framebuffer, time >> 3);\n        // this.drawOldPlaneDeformationFloor(framebuffer, time >> 3);\n        this.drawPlaneDeformation(framebuffer, time >> 3, time >> 3);\n    }\n\n    /**\n     * For every frame, go through every pixel and use the reference table (mLUT)\n     * to get which pixel of the texture it should draw at the current pixel.\n     *\n     * TODO:\n     * - Rotate effect via rotozoomer class\n     *   use drawOldPlaneDeformationStar to add another lookup layer [mLUT * 4]\n     *   use drawOldPlaneDeformationFloor to update createLUT(8) floor algorithm\n     *\n     */\n    drawPlaneDeformation(framebuffer: Framebuffer, elapsedTimeY: number, elapsedTimeX: number) {\n\n        for (let pixelCount = 0; pixelCount < framebuffer.framebuffer.length; pixelCount++) {\n            const o = (pixelCount << 1) + pixelCount; // equivalent to 3 * pixelCount\n            const u = this.mLUT[o + 0] + elapsedTimeX; // to look like its animating, add timeDisplacement\n            const v = this.mLUT[o + 1] + elapsedTimeY;\n            const adjustBrightness = this.mLUT[o + 2]; // fade out\n\n            // get the R,G,B values from texture\n            let currentPixel = this.texture.texture[this.texture.width * (v & this.texture.height - 1) + (u & this.texture.width - 1)];\n\n            // only apply brightness if it was calculated\n            if (adjustBrightness !== 0) {\n\n                // disassemble pixel using bit mask to remove color components for greater speed\n                let r = currentPixel & 0xFF;        // get red\n                let g = currentPixel >> 8 & 0xFF;   // get green\n                let b = currentPixel >> 16 & 0xFF;  // get blue\n\n                // make darker or brighter\n                r += adjustBrightness;\n                g += adjustBrightness;\n                b += adjustBrightness;\n\n                // constrain RGB to make sure they are within 0-255 color range\n                r = Utils.clamp(r, 0, 255);\n                g = Utils.clamp(g, 0, 255);\n                b = Utils.clamp(b, 0, 255);\n\n                // reassemble colors back into pixel\n                currentPixel = new Color(r, g, b, 255).toPackedFormat();\n            }\n\n            // put texture pixel on buffer screen\n            framebuffer.framebuffer[pixelCount] = currentPixel;\n        }\n    }\n\n    /**\n     *\n     * Previous Plane deformation without lookup tables for reference\n     *\n     * http://sol.gfxile.net/gp/ch17.html\n     * TODO:\n     * - better textures\n     * - precalc lookup tables\n     * - fadeout\n     * - substraction to create black holes\n     */\n    drawOldPlaneDeformationFloor(framebuffer: Framebuffer, elapsedTime: number) {\n        /*\n        mLUT(8)\n            u = x / Math.abs(y);\n            v = 1 / Math.abs(y);\n            bright = 10 * -v;\n        */\n        let i = 0;\n        for (let y = 0; y < framebuffer.height; y++) {\n            const ydist = (y - framebuffer.height / 2);\n            const v = (((1 / Math.abs(ydist / 100 * 0.02) + elapsedTime * 0.069) % 256) + 256) % 256;\n            const alpha = 1 - Math.min(1, (1 / Math.abs(ydist / 10)));\n            for (let x = 0; x < framebuffer.width; x++) {\n                const xdist = (x - (framebuffer.width / 2));\n                const u = (((((xdist / framebuffer.width) / Math.abs(ydist / 100 * 0.02))) % 256) + 256) % 256;\n                const color1 = this.texture.texture[(u | 0) + (v | 0) * 256];\n                const r = (((color1 >> 0) & 0xff) * (alpha)) | 0;\n                const g = (((color1 >> 8) & 0xff) * (alpha)) | 0;\n                const b = (((color1 >> 16) & 0xff) * (alpha)) | 0;\n                framebuffer.framebuffer[i++] = r | g << 8 | b << 16 | 255 << 24;\n            }\n        }\n    }\n\n    drawOldPlaneDeformationStar(framebuffer: Framebuffer, elapsedTime: number) {\n        let i = 0;\n        for (let y = 0; y < framebuffer.height; y++) {\n            for (let x = 0; x < framebuffer.width; x++) {\n                const xdist = (x - (framebuffer.width / 2)) / (framebuffer.width / 2);\n                const ydist = (y - framebuffer.height / 2) / (framebuffer.height / 2);\n                const alpha = 1;// 1 - Math.min(1, (1 / Math.abs(ydist / 10)));\n                const a = Math.atan2(ydist, xdist) + elapsedTime * 0.0004;\n                const v = (a * 3 / Math.PI + elapsedTime * 0.0004) * 128 % 256;\n                const d = Math.sqrt(xdist * xdist + ydist * ydist);\n                const u = (1 / (d + 0.5 + 0.5 * Math.sin(5 * a)) * 32 + elapsedTime * 0.03) % 256;\n                const color1 = this.texture.texture[(u | 0) + (v | 0) * 256];\n                const r = (((color1 >> 0) & 0xff) * (alpha)) | 0;\n                const g = (((color1 >> 8) & 0xff) * (alpha)) | 0;\n                const b = (((color1 >> 16) & 0xff) * (alpha)) | 0;\n                framebuffer.framebuffer[i++] = r | g << 8 | b << 16 | 255 << 24;\n            }\n        }\n    }\n\n}\n"],"names":["DistortedSphereScene","AbstractScene","heightmapSphere","env","obj","texturedRenderingPipeline","init","framebuffer","this","TexturingRenderingPipeline","Promise","all","TextureUtils","load","then","texture","createSphereDistplaced","render","time","clearColorBuffer","Color","BLACK","toPackedFormat","renderTransparent","setCullFace","CullFace","BACK","setTexture","modelViewMartrix","Matrix4f","constructScaleMatrix","multiplyMatrix","constructYRotationMatrix","constructXRotationMatrix","constructTranslationMatrix","Math","sin","clearDepthBuffer","shadingSphereEnvDisp2","createSphere","pointsA","Vector4f","k","divideSphere","points","points2","normals","normals2","index","forEach","i","p","point","find","findPoint","sub","length","idx","indexOf","push","steps","index2","c","v1","v2","v3","vn1","mul","add","normalize","vn2","vn3","sphere","newPoints","Array","x","y","z","u","floor","atan2","PI","v","asin","disp","elapsedTime","result","sqrt","rot","max","cos","norm","norm2","cross","sub2","cross2","normal","add2","normalize2","normalMatrix","computeNormalMatrix","n","multiplyHomArr","transformed","multiplyHom","round","width","height","vertex1","Vertex","textureCoordinate","TextureCoordinate","vertex2","vertex3","vertexArray","n1","n2","n3","isTriangleCCW","projection","fakeSphere","minWindow","maxWindow","clipConvexPolygon","triangleRasterizer","drawTriangleDDA","Scene6","PlaneDeformationScene","logo","drawTexture","effectStyle","texturePath","mLUT","constructor","onInit","createLUT","effectWidth","effectHeight","textureWidth","textureHeight","Int32Array","bright","j","d","a","r","pow","abs","clamp","drawPlaneDeformation","elapsedTimeY","elapsedTimeX","pixelCount","o","adjustBrightness","currentPixel","g","b","drawOldPlaneDeformationFloor","ydist","alpha","min","color1","drawOldPlaneDeformationStar","xdist"],"sourceRoot":""}